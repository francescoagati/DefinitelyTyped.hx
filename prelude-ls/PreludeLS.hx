extern class PreludeLSTopLevel {
	static function id<A>(x:A):A;
	static function isType<A>(type:String):A -> Bool;
	static function isType<A>(type:String, x:A):Bool;
	static function replicate<A>(n:Float):A -> Array<A>;
	static function replicate<A>(n:Float, x:A):Array<A>;
	static function each<A>(f:A -> Void):Array<A> -> Void;
	static function each<A>(f:A -> Void, xs:Array<A>):Void;
	static function map<A, B>(f:A -> B):Array<A> -> Array<B>;
	static function map<A, B>(f:A -> B, xs:Array<A>):Array<B>;
	static function compact<A>(xs:Array<A>):Array<A>;
	static function filter<A>(f:A -> Bool):Array<A> -> Array<A>;
	static function filter<A>(f:A -> Bool, xs:Array<A>):Array<A>;
	static function reject<A>(f:A -> Bool):Array<A> -> Array<A>;
	static function reject<A>(f:A -> Bool, xs:Array<A>):Array<A>;
	static function partition<A>(f:A -> Boolean):Array<A> -> Array<Dynamic>;
	static function partition<A>(f:A -> Boolean, xs:Array<A>):Array<Dynamic>;
	static function find<A>(f:A -> Boolean):Array<A> -> haxe.extern.EitherType<A, Void>;
	static function find<A>(f:A -> Boolean, xs:Array<A>):haxe.extern.EitherType<A, Void>;
	static function head<A>(xs:Array<A>):haxe.extern.EitherType<A, Void>;
	static function tail<A>(xs:Array<A>):Array<A>;
	static function last<A>(xs:Array<A>):haxe.extern.EitherType<A, Void>;
	static function initial<A>(xs:Array<A>):Array<A>;
	static function empty<A>(xs:Array<A>):Bool;
	static function reverse<A>(xs:Array<A>):Array<A>;
	static function unique<A>(xs:Array<A>):Array<A>;
	static function uniqueBy<A, B>(f:A -> B):Array<A> -> Array<A>;
	static function uniqueBy<A, B>(f:A -> B, xs:Array<A>):Array<A>;
	static function fold<A, B>(f:A -> B -> A):A -> Array<B> -> A;
	static function fold<A, B>(f:A -> B -> A, memo:A):Array<B> -> A;
	static function fold<A, B>(f:A -> B -> A, memo:A, xs:Array<B>):A;
	static function foldl<A, B>(f:A -> B -> A):A -> Array<B> -> A;
	static function foldl<A, B>(f:A -> B -> A, memo:A):Array<B> -> A;
	static function foldl<A, B>(f:A -> B -> A, memo:A, xs:Array<B>):A;
	static function fold1<A>(f:A -> A -> A):Array<A> -> A;
	static function fold1<A>(f:A -> A -> A, xs:Array<A>):A;
	static function foldl1<A>(f:A -> A -> A):Array<A> -> A;
	static function foldl1<A>(f:A -> A -> A, xs:Array<A>):A;
	static function foldr<A, B>(f:A -> B -> B):B -> Array<A> -> B;
	static function foldr<A, B>(f:A -> B -> B, memo:B):Array<A> -> B;
	static function foldr<A, B>(f:A -> B -> B, memo:B, xs:Array<A>):B;
	static function foldr1<A>(f:A -> A -> A):Array<A> -> A;
	static function foldr1<A>(f:A -> A -> A, xs:Array<A>):A;
	static function unfoldr<A, B>(f:B -> haxe.extern.EitherType<Array<Dynamic>, Void>):B -> Array<A>;
	static function unfoldr<A, B>(f:B -> haxe.extern.EitherType<Array<Dynamic>, Void>, x:B):Array<A>;
	static function concat<A>(xss:Array<Array<A>>):Array<A>;
	static function concatMap<A, B>(f:A -> Array<B>):Array<A> -> Array<B>;
	static function concatMap<A, B>(f:A -> Array<B>, xs:Array<A>):Array<B>;
	static function flatten(xs:Array<Dynamic>):Array<Dynamic>;
	static function difference<A>(xss:haxe.extern.Rest<Array<A>>):Array<A>;
	static function intersection<A>(xss:haxe.extern.Rest<A>):Array<A>;
	static function union<A>(xss:haxe.extern.Rest<A>):Array<A>;
	static function countBy<A, B>(f:A -> B):Array<A> -> Dynamic;
	static function countBy<A, B>(f:A -> B, xs:Array<A>):Dynamic;
	static function groupBy<A, B>(f:A -> B):Array<A> -> Dynamic;
	static function groupBy<A, B>(f:A -> B, xs:Array<A>):Dynamic;
	static function andList<A>(xs:Array<A>):Bool;
	static function orList<A>(xs:Array<A>):Bool;
	static function any<A>(f:A -> Bool):Array<A> -> Bool;
	static function any<A>(f:A -> Bool, xs:Array<A>):Bool;
	static function all<A>(f:A -> Bool):Array<A> -> Bool;
	static function all<A>(f:A -> Bool, xs:Array<A>):Bool;
	static function sort<A>(xs:Array<A>):Array<A>;
	static function sortWith<A>(f:A -> A -> Float):Array<A> -> Array<A>;
	static function sortWith<A>(f:A -> A -> Float, xs:Array<A>):Array<A>;
	static function sortBy<A, B>(f:A -> B):Array<A> -> A;
	static function sortBy<A, B>(f:A -> B, xs:Array<A>):A;
	static function sum(xs:Array<Float>):Array<Float>;
	static function product(xs:Array<Float>):Array<Float>;
	static function mean(xs:Array<Float>):Array<Float>;
	static function maximum<A>(xs:Array<A>):A;
	static function minimum<A>(xs:Array<A>):A;
	static function maximumBy<A, B>(f:A -> B):Array<A> -> A;
	static function maximumBy<A, B>(f:A -> B, xs:Array<A>):A;
	static function minimumBy<A, B>(f:A -> B):Array<A> -> A;
	static function minimumBy<A, B>(f:A -> B, xs:Array<A>):A;
	static function scan<A, B>(f:A -> B -> A):A -> Array<B> -> Array<A>;
	static function scan<A, B>(f:A -> B -> A, memo:A):Array<B> -> Array<A>;
	static function scan<A, B>(f:A -> B -> A, memo:A, xs:Array<B>):Array<A>;
	static function scanl<A, B>(f:A -> B -> A):A -> Array<B> -> Array<A>;
	static function scanl<A, B>(f:A -> B -> A, memo:A):Array<B> -> Array<A>;
	static function scanl<A, B>(f:A -> B -> A, memo:A, xs:Array<B>):Array<A>;
	static function scan1<A>(f:A -> A -> A):Array<A> -> Array<A>;
	static function scan1<A>(f:A -> A -> A, xs:Array<A>):Array<A>;
	static function scanl1<A>(f:A -> A -> A):Array<A> -> Array<A>;
	static function scanl1<A>(f:A -> A -> A, xs:Array<A>):Array<A>;
	static function scanr<A, B>(f:A -> B -> B):B -> Array<A> -> Array<B>;
	static function scanr<A, B>(f:A -> B -> B, memo:B):Array<A> -> Array<B>;
	static function scanr<A, B>(f:A -> B -> B, memo:B, xs:Array<A>):Array<B>;
	static function scanr1<A>(f:A -> A -> A):Array<A> -> Array<A>;
	static function scanr1<A>(f:A -> A -> A, xs:Array<A>):Array<A>;
	static function slice<A>(x:Float):Float -> Array<A> -> Array<A>;
	static function slice<A>(x:Float, y:Float):Array<A> -> Array<A>;
	static function slice<A>(x:Float, y:Float, xs:Array<A>):Array<A>;
	static function take<A>(n:Float):Array<A> -> Array<A>;
	static function take<A>(n:Float, xs:Array<A>):Array<A>;
	static function drop<A>(n:Float):Array<A> -> Array<A>;
	static function drop<A>(n:Float, xs:Array<A>):Array<A>;
	static function splitAt<A>(n:Float):Array<A> -> Array<Dynamic>;
	static function splitAt<A>(n:Float, xs:Array<A>):Array<Dynamic>;
	static function takeWhile<A>(p:A -> Bool):Array<A> -> Array<A>;
	static function takeWhile<A>(p:A -> Bool, xs:Array<A>):Array<A>;
	static function dropWhile<A>(p:A -> Bool):Array<A> -> Array<A>;
	static function dropWhile<A>(p:A -> Bool, xs:Array<A>):Array<A>;
	static function span<A>(p:A -> Bool):Array<A> -> Array<Dynamic>;
	static function span<A>(p:A -> Bool, xs:Array<A>):Array<Dynamic>;
	static function breakList<A>(p:A -> Bool):Array<A> -> Array<Dynamic>;
	static function breakList<A>(p:A -> Bool, xs:Array<A>):Array<Dynamic>;
	static function zip<A, B>(xs:Array<A>):Array<B> -> Array<Array<Dynamic>>;
	static function zip<A, B>(xs:Array<A>, ys:Array<B>):Array<Array<Dynamic>>;
	static function zipWith<A, B, C>(f:A -> B -> C):Array<A> -> Array<B> -> Array<C>;
	static function zipWith<A, B, C>(f:A -> B -> C, xs:Array<A>):Array<B> -> Array<C>;
	static function zipWith<A, B, C>(f:A -> B -> C, xs:Array<A>, ys:Array<B>):Array<C>;
	static function zipAll<A>(xss:haxe.extern.Rest<Array<A>>):Array<Array<A>>;
	static function zipAllWith<A, B>(f:haxe.extern.Rest<A> -> B, xss:haxe.extern.Rest<Array<A>>):Array<B>;
	static function at<A>(n:Float):Array<A> -> A;
	static function at<A>(n:Float, xs:Array<A>):A;
	static function elemIndex<A>(x:A):Array<A> -> Float;
	static function elemIndex<A>(x:A, xs:Array<A>):Float;
	static function elemIndices<A>(x:A):Array<A> -> Array<Float>;
	static function elemIndices<A>(x:A, xs:Array<A>):Array<Float>;
	static function findIndex<A>(f:A -> Bool):Array<A> -> Float;
	static function findIndex<A>(f:A -> Bool, xs:Array<A>):Float;
	static function findIndices<A>(f:A -> Bool):Array<A> -> Array<Float>;
	static function findIndices<A>(f:A -> Bool, xs:Array<A>):Array<Float>;
	static function keys<A>(object:{ }):Array<String>;
	static function keys<A>(object:{ }):Array<Float>;
	static function values<A>(object:{ }):Array<A>;
	static function values<A>(object:{ }):Array<A>;
	static function pairsToObj<A>(object:Array<Array<Dynamic>>):{ };
	static function pairsToObj<A>(object:Array<Array<Dynamic>>):{ };
	static function objToPairs<A>(object:{ }):Array<Array<Dynamic>>;
	static function objToPairs<A>(object:{ }):Array<Array<Dynamic>>;
	static function listsToObj<A>(keys:Array<String>):Array<A> -> { };
	static function listsToObj<A>(keys:Array<String>, values:Array<A>):{ };
	static function listsToObj<A>(keys:Array<Float>):Array<A> -> { };
	static function listsToObj<A>(keys:Array<Float>, values:Array<A>):{ };
	static function objToLists<A>(object:{ }):Array<Dynamic>;
	static function objToLists<A>(object:{ }):Array<Dynamic>;
	static function empty<A>(object:Dynamic):Bool;
	static function each<A>(f:A -> Void):{ } -> { };
	static function each<A>(f:A -> Void, object:{ }):{ };
	static function each<A>(f:A -> Void):{ } -> { };
	static function each<A>(f:A -> Void, object:{ }):{ };
	static function map<A, B>(f:A -> B):{ } -> { };
	static function map<A, B>(f:A -> B, object:{ }):{ };
	static function map<A, B>(f:A -> B):{ } -> { };
	static function map<A, B>(f:A -> B, object:{ }):{ };
	static function compact<A>(object:{ }):{ };
	static function compact<A>(object:{ }):{ };
	static function filter<A>(f:A -> Bool):{ } -> { };
	static function filter<A>(f:A -> Bool, object:{ }):{ };
	static function filter<A>(f:A -> Bool):{ } -> { };
	static function filter<A>(f:A -> Bool, object:{ }):{ };
	static function reject<A>(f:A -> Bool):{ } -> { };
	static function reject<A>(f:A -> Bool, object:{ }):{ };
	static function reject<A>(f:A -> Bool):{ } -> { };
	static function reject<A>(f:A -> Bool, object:{ }):{ };
	static function partition<A>(f:A -> Bool):{ } -> Array<Dynamic>;
	static function partition<A>(f:A -> Bool, object:{ }):Array<Dynamic>;
	static function partition<A>(f:A -> Bool):{ } -> Array<Dynamic>;
	static function partition<A>(f:A -> Bool, object:{ }):Array<Dynamic>;
	static function find<A>(f:A -> Bool):{ } -> A;
	static function find<A>(f:A -> Bool, object:{ }):A;
	static function find<A>(f:A -> Bool):{ } -> A;
	static function find<A>(f:A -> Bool, object:{ }):A;
}
