extern class StrTopLevel {
	static function empty(str:String):Bool;
	static function reverse(str:String):String;
	static function slice(x:Float):Float -> String -> String;
	static function slice(x:Float, y:Float):String -> String;
	static function slice(x:Float, y:Float, str:String):String;
	static function take(n:Float):String -> String;
	static function take(n:Float, str:String):String;
	static function drop(n:Float):String -> String;
	static function drop(n:Float, str:String):String;
	static function splitAt(n:Float):String -> Array<Dynamic>;
	static function splitAt(n:Float, str:String):Array<Dynamic>;
	static function takeWhile(f:String -> Bool):String -> String;
	static function takeWhile(f:String -> Bool, str:String):String;
	static function dropWhile(f:String -> Bool):String -> String;
	static function dropWhile(f:String -> Bool, str:String):String;
	static function span(f:String -> Bool):String -> Array<Dynamic>;
	static function span(f:String -> Bool, str:String):Array<Dynamic>;
	static function breakStr(f:String -> Bool):String -> Array<Dynamic>;
	static function breakStr(f:String -> Bool, str:String):Array<Dynamic>;
	static function apply<A, B>(f:haxe.extern.Rest<A> -> B):Array<A> -> B;
	static function apply<A, B>(f:haxe.extern.Rest<A> -> B, args:Array<A>):B;
	static function curry(f:haxe.Constraints.Function):haxe.Constraints.Function;
	static function flip<A, B, C>(f:A -> B -> C):B -> A -> C;
	static function flip<A, B, C>(f:A -> B -> C, y:B):A -> C;
	static function flip<A, B, C>(f:A -> B -> C, y:B, x:A):C;
	static function fix(f:haxe.Constraints.Function):haxe.Constraints.Function;
	static function over<A, B, C>(f:B -> B -> C):A -> B -> A -> A -> C;
	static function over<A, B, C>(f:B -> B -> C):A -> B -> A -> A -> C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B):A -> A -> C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B):A -> A -> C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B, x:A):A -> C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B, x:A):A -> C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B, x:A, y:A):C;
	static function over<A, B, C>(f:B -> B -> C, g:A -> B, x:A, y:A):C;
	static function max<Comparable>(x:Comparable):Comparable -> Comparable;
	static function max<Comparable>(x:Comparable, y:Comparable):Comparable;
	static function min<Comparable>(x:Comparable):Comparable -> Comparable;
	static function min<Comparable>(x:Comparable, y:Comparable):Comparable;
	static function negate(x:Float):Float;
	static function abs(x:Float):Float;
	static function signum(x:Float):Float;
	static function quot(x:Float):Float -> Float;
	static function quot(x:Float, y:Float):Float;
	static function rem(x:Float):Float -> Float;
	static function rem(x:Float, y:Float):Float;
	static function div(x:Float):Float -> Float;
	static function div(x:Float, y:Float):Float;
	static function mod(x:Float):Float -> Float;
	static function mod(x:Float, y:Float):Float;
	static function recip(x:Float):Float;
	static var pi : Float;
	static var tau : Float;
	static function exp(x:Float):Float;
	static function sqrt(x:Float):Float;
	static function ln(x:Float):Float;
	static function pow(x:Float):Float -> Float;
	static function pow(x:Float, y:Float):Float;
	static function sin(x:Float):Float;
	static function cos(x:Float):Float;
	static function tan(x:Float):Float;
	static function asin(x:Float):Float;
	static function acos(x:Float):Float;
	static function atan(x:Float):Float;
	static function atan2(x:Float, y:Float):Float;
	static function truncate(x:Float):Float;
	static function round(x:Float):Float;
	static function ceiling(x:Float):Float;
	static function floor(x:Float):Float;
	static function isItNaN(x:Float):Bool;
	static function even(x:Float):Bool;
	static function odd(x:Float):Bool;
	static function gcd(x:Float):Float -> Float;
	static function gcd(x:Float, y:Float):Float;
	static function lcm(x:Float):Float -> Float;
	static function lcm(x:Float, y:Float):Float;
}
