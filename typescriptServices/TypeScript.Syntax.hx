extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
typedef IFactory = {
	function sourceUnit(moduleElements:ISyntaxList, endOfFileToken:ISyntaxToken):SourceUnitSyntax;
	function externalModuleReference(requireKeyword:ISyntaxToken, openParenToken:ISyntaxToken, stringLiteral:ISyntaxToken, closeParenToken:ISyntaxToken):ExternalModuleReferenceSyntax;
	function moduleNameModuleReference(moduleName:INameSyntax):ModuleNameModuleReferenceSyntax;
	function importDeclaration(modifiers:ISyntaxList, importKeyword:ISyntaxToken, identifier:ISyntaxToken, equalsToken:ISyntaxToken, moduleReference:IModuleReferenceSyntax, semicolonToken:ISyntaxToken):ImportDeclarationSyntax;
	function exportAssignment(exportKeyword:ISyntaxToken, equalsToken:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ExportAssignmentSyntax;
	function classDeclaration(modifiers:ISyntaxList, classKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, openBraceToken:ISyntaxToken, classElements:ISyntaxList, closeBraceToken:ISyntaxToken):ClassDeclarationSyntax;
	function interfaceDeclaration(modifiers:ISyntaxList, interfaceKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, body:ObjectTypeSyntax):InterfaceDeclarationSyntax;
	function heritageClause(kind:SyntaxKind, extendsOrImplementsKeyword:ISyntaxToken, typeNames:ISeparatedSyntaxList):HeritageClauseSyntax;
	function moduleDeclaration(modifiers:ISyntaxList, moduleKeyword:ISyntaxToken, name:INameSyntax, stringLiteral:ISyntaxToken, openBraceToken:ISyntaxToken, moduleElements:ISyntaxList, closeBraceToken:ISyntaxToken):ModuleDeclarationSyntax;
	function functionDeclaration(modifiers:ISyntaxList, functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):FunctionDeclarationSyntax;
	function variableStatement(modifiers:ISyntaxList, variableDeclaration:VariableDeclarationSyntax, semicolonToken:ISyntaxToken):VariableStatementSyntax;
	function variableDeclaration(varKeyword:ISyntaxToken, variableDeclarators:ISeparatedSyntaxList):VariableDeclarationSyntax;
	function variableDeclarator(propertyName:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):VariableDeclaratorSyntax;
	function equalsValueClause(equalsToken:ISyntaxToken, value:IExpressionSyntax):EqualsValueClauseSyntax;
	function prefixUnaryExpression(kind:SyntaxKind, operatorToken:ISyntaxToken, operand:IUnaryExpressionSyntax):PrefixUnaryExpressionSyntax;
	function arrayLiteralExpression(openBracketToken:ISyntaxToken, expressions:ISeparatedSyntaxList, closeBracketToken:ISyntaxToken):ArrayLiteralExpressionSyntax;
	function omittedExpression():OmittedExpressionSyntax;
	function parenthesizedExpression(openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken):ParenthesizedExpressionSyntax;
	function simpleArrowFunctionExpression(identifier:ISyntaxToken, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):SimpleArrowFunctionExpressionSyntax;
	function parenthesizedArrowFunctionExpression(callSignature:CallSignatureSyntax, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):ParenthesizedArrowFunctionExpressionSyntax;
	function qualifiedName(left:INameSyntax, dotToken:ISyntaxToken, right:ISyntaxToken):QualifiedNameSyntax;
	function typeArgumentList(lessThanToken:ISyntaxToken, typeArguments:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeArgumentListSyntax;
	function constructorType(newKeyword:ISyntaxToken, typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):ConstructorTypeSyntax;
	function functionType(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):FunctionTypeSyntax;
	function objectType(openBraceToken:ISyntaxToken, typeMembers:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectTypeSyntax;
	function arrayType(type:ITypeSyntax, openBracketToken:ISyntaxToken, closeBracketToken:ISyntaxToken):ArrayTypeSyntax;
	function genericType(name:INameSyntax, typeArgumentList:TypeArgumentListSyntax):GenericTypeSyntax;
	function typeQuery(typeOfKeyword:ISyntaxToken, name:INameSyntax):TypeQuerySyntax;
	function typeAnnotation(colonToken:ISyntaxToken, type:ITypeSyntax):TypeAnnotationSyntax;
	function block(openBraceToken:ISyntaxToken, statements:ISyntaxList, closeBraceToken:ISyntaxToken):BlockSyntax;
	function parameter(dotDotDotToken:ISyntaxToken, modifiers:ISyntaxList, identifier:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):ParameterSyntax;
	function memberAccessExpression(expression:IExpressionSyntax, dotToken:ISyntaxToken, name:ISyntaxToken):MemberAccessExpressionSyntax;
	function postfixUnaryExpression(kind:SyntaxKind, operand:IMemberExpressionSyntax, operatorToken:ISyntaxToken):PostfixUnaryExpressionSyntax;
	function elementAccessExpression(expression:IExpressionSyntax, openBracketToken:ISyntaxToken, argumentExpression:IExpressionSyntax, closeBracketToken:ISyntaxToken):ElementAccessExpressionSyntax;
	function invocationExpression(expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):InvocationExpressionSyntax;
	function argumentList(typeArgumentList:TypeArgumentListSyntax, openParenToken:ISyntaxToken, arguments:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ArgumentListSyntax;
	function binaryExpression(kind:SyntaxKind, left:IExpressionSyntax, operatorToken:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	function conditionalExpression(condition:IExpressionSyntax, questionToken:ISyntaxToken, whenTrue:IExpressionSyntax, colonToken:ISyntaxToken, whenFalse:IExpressionSyntax):ConditionalExpressionSyntax;
	function constructSignature(newKeyword:ISyntaxToken, callSignature:CallSignatureSyntax):ConstructSignatureSyntax;
	function methodSignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, callSignature:CallSignatureSyntax):MethodSignatureSyntax;
	function indexSignature(openBracketToken:ISyntaxToken, parameter:ParameterSyntax, closeBracketToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):IndexSignatureSyntax;
	function propertySignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):PropertySignatureSyntax;
	function callSignature(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax):CallSignatureSyntax;
	function parameterList(openParenToken:ISyntaxToken, parameters:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ParameterListSyntax;
	function typeParameterList(lessThanToken:ISyntaxToken, typeParameters:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeParameterListSyntax;
	function typeParameter(identifier:ISyntaxToken, constraint:ConstraintSyntax):TypeParameterSyntax;
	function constraint(extendsKeyword:ISyntaxToken, type:ITypeSyntax):ConstraintSyntax;
	function elseClause(elseKeyword:ISyntaxToken, statement:IStatementSyntax):ElseClauseSyntax;
	function ifStatement(ifKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax, elseClause:ElseClauseSyntax):IfStatementSyntax;
	function expressionStatement(expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ExpressionStatementSyntax;
	function constructorDeclaration(modifiers:ISyntaxList, constructorKeyword:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):ConstructorDeclarationSyntax;
	function memberFunctionDeclaration(modifiers:ISyntaxList, propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):MemberFunctionDeclarationSyntax;
	function getAccessor(modifiers:ISyntaxList, getKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax, block:BlockSyntax):GetAccessorSyntax;
	function setAccessor(modifiers:ISyntaxList, setKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, block:BlockSyntax):SetAccessorSyntax;
	function memberVariableDeclaration(modifiers:ISyntaxList, variableDeclarator:VariableDeclaratorSyntax, semicolonToken:ISyntaxToken):MemberVariableDeclarationSyntax;
	function indexMemberDeclaration(modifiers:ISyntaxList, indexSignature:IndexSignatureSyntax, semicolonToken:ISyntaxToken):IndexMemberDeclarationSyntax;
	function throwStatement(throwKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ThrowStatementSyntax;
	function returnStatement(returnKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ReturnStatementSyntax;
	function objectCreationExpression(newKeyword:ISyntaxToken, expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):ObjectCreationExpressionSyntax;
	function switchStatement(switchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, openBraceToken:ISyntaxToken, switchClauses:ISyntaxList, closeBraceToken:ISyntaxToken):SwitchStatementSyntax;
	function caseSwitchClause(caseKeyword:ISyntaxToken, expression:IExpressionSyntax, colonToken:ISyntaxToken, statements:ISyntaxList):CaseSwitchClauseSyntax;
	function defaultSwitchClause(defaultKeyword:ISyntaxToken, colonToken:ISyntaxToken, statements:ISyntaxList):DefaultSwitchClauseSyntax;
	function breakStatement(breakKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):BreakStatementSyntax;
	function continueStatement(continueKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ContinueStatementSyntax;
	function forStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, initializer:IExpressionSyntax, firstSemicolonToken:ISyntaxToken, condition:IExpressionSyntax, secondSemicolonToken:ISyntaxToken, incrementor:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForStatementSyntax;
	function forInStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, left:IExpressionSyntax, inKeyword:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForInStatementSyntax;
	function whileStatement(whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WhileStatementSyntax;
	function withStatement(withKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WithStatementSyntax;
	function enumDeclaration(modifiers:ISyntaxList, enumKeyword:ISyntaxToken, identifier:ISyntaxToken, openBraceToken:ISyntaxToken, enumElements:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):EnumDeclarationSyntax;
	function enumElement(propertyName:ISyntaxToken, equalsValueClause:EqualsValueClauseSyntax):EnumElementSyntax;
	function castExpression(lessThanToken:ISyntaxToken, type:ITypeSyntax, greaterThanToken:ISyntaxToken, expression:IUnaryExpressionSyntax):CastExpressionSyntax;
	function objectLiteralExpression(openBraceToken:ISyntaxToken, propertyAssignments:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectLiteralExpressionSyntax;
	function simplePropertyAssignment(propertyName:ISyntaxToken, colonToken:ISyntaxToken, expression:IExpressionSyntax):SimplePropertyAssignmentSyntax;
	function functionPropertyAssignment(propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionPropertyAssignmentSyntax;
	function functionExpression(functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionExpressionSyntax;
	function emptyStatement(semicolonToken:ISyntaxToken):EmptyStatementSyntax;
	function tryStatement(tryKeyword:ISyntaxToken, block:BlockSyntax, catchClause:CatchClauseSyntax, finallyClause:FinallyClauseSyntax):TryStatementSyntax;
	function catchClause(catchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, identifier:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, closeParenToken:ISyntaxToken, block:BlockSyntax):CatchClauseSyntax;
	function finallyClause(finallyKeyword:ISyntaxToken, block:BlockSyntax):FinallyClauseSyntax;
	function labeledStatement(identifier:ISyntaxToken, colonToken:ISyntaxToken, statement:IStatementSyntax):LabeledStatementSyntax;
	function doStatement(doKeyword:ISyntaxToken, statement:IStatementSyntax, whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, semicolonToken:ISyntaxToken):DoStatementSyntax;
	function typeOfExpression(typeOfKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):TypeOfExpressionSyntax;
	function deleteExpression(deleteKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):DeleteExpressionSyntax;
	function voidExpression(voidKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):VoidExpressionSyntax;
	function debuggerStatement(debuggerKeyword:ISyntaxToken, semicolonToken:ISyntaxToken):DebuggerStatementSyntax;
};
extern class NormalModeFactory {
	function sourceUnit(moduleElements:ISyntaxList, endOfFileToken:ISyntaxToken):SourceUnitSyntax;
	function externalModuleReference(requireKeyword:ISyntaxToken, openParenToken:ISyntaxToken, stringLiteral:ISyntaxToken, closeParenToken:ISyntaxToken):ExternalModuleReferenceSyntax;
	function moduleNameModuleReference(moduleName:INameSyntax):ModuleNameModuleReferenceSyntax;
	function importDeclaration(modifiers:ISyntaxList, importKeyword:ISyntaxToken, identifier:ISyntaxToken, equalsToken:ISyntaxToken, moduleReference:IModuleReferenceSyntax, semicolonToken:ISyntaxToken):ImportDeclarationSyntax;
	function exportAssignment(exportKeyword:ISyntaxToken, equalsToken:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ExportAssignmentSyntax;
	function classDeclaration(modifiers:ISyntaxList, classKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, openBraceToken:ISyntaxToken, classElements:ISyntaxList, closeBraceToken:ISyntaxToken):ClassDeclarationSyntax;
	function interfaceDeclaration(modifiers:ISyntaxList, interfaceKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, body:ObjectTypeSyntax):InterfaceDeclarationSyntax;
	function heritageClause(kind:SyntaxKind, extendsOrImplementsKeyword:ISyntaxToken, typeNames:ISeparatedSyntaxList):HeritageClauseSyntax;
	function moduleDeclaration(modifiers:ISyntaxList, moduleKeyword:ISyntaxToken, name:INameSyntax, stringLiteral:ISyntaxToken, openBraceToken:ISyntaxToken, moduleElements:ISyntaxList, closeBraceToken:ISyntaxToken):ModuleDeclarationSyntax;
	function functionDeclaration(modifiers:ISyntaxList, functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):FunctionDeclarationSyntax;
	function variableStatement(modifiers:ISyntaxList, variableDeclaration:VariableDeclarationSyntax, semicolonToken:ISyntaxToken):VariableStatementSyntax;
	function variableDeclaration(varKeyword:ISyntaxToken, variableDeclarators:ISeparatedSyntaxList):VariableDeclarationSyntax;
	function variableDeclarator(propertyName:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):VariableDeclaratorSyntax;
	function equalsValueClause(equalsToken:ISyntaxToken, value:IExpressionSyntax):EqualsValueClauseSyntax;
	function prefixUnaryExpression(kind:SyntaxKind, operatorToken:ISyntaxToken, operand:IUnaryExpressionSyntax):PrefixUnaryExpressionSyntax;
	function arrayLiteralExpression(openBracketToken:ISyntaxToken, expressions:ISeparatedSyntaxList, closeBracketToken:ISyntaxToken):ArrayLiteralExpressionSyntax;
	function omittedExpression():OmittedExpressionSyntax;
	function parenthesizedExpression(openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken):ParenthesizedExpressionSyntax;
	function simpleArrowFunctionExpression(identifier:ISyntaxToken, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):SimpleArrowFunctionExpressionSyntax;
	function parenthesizedArrowFunctionExpression(callSignature:CallSignatureSyntax, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):ParenthesizedArrowFunctionExpressionSyntax;
	function qualifiedName(left:INameSyntax, dotToken:ISyntaxToken, right:ISyntaxToken):QualifiedNameSyntax;
	function typeArgumentList(lessThanToken:ISyntaxToken, typeArguments:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeArgumentListSyntax;
	function constructorType(newKeyword:ISyntaxToken, typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):ConstructorTypeSyntax;
	function functionType(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):FunctionTypeSyntax;
	function objectType(openBraceToken:ISyntaxToken, typeMembers:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectTypeSyntax;
	function arrayType(type:ITypeSyntax, openBracketToken:ISyntaxToken, closeBracketToken:ISyntaxToken):ArrayTypeSyntax;
	function genericType(name:INameSyntax, typeArgumentList:TypeArgumentListSyntax):GenericTypeSyntax;
	function typeQuery(typeOfKeyword:ISyntaxToken, name:INameSyntax):TypeQuerySyntax;
	function typeAnnotation(colonToken:ISyntaxToken, type:ITypeSyntax):TypeAnnotationSyntax;
	function block(openBraceToken:ISyntaxToken, statements:ISyntaxList, closeBraceToken:ISyntaxToken):BlockSyntax;
	function parameter(dotDotDotToken:ISyntaxToken, modifiers:ISyntaxList, identifier:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):ParameterSyntax;
	function memberAccessExpression(expression:IExpressionSyntax, dotToken:ISyntaxToken, name:ISyntaxToken):MemberAccessExpressionSyntax;
	function postfixUnaryExpression(kind:SyntaxKind, operand:IMemberExpressionSyntax, operatorToken:ISyntaxToken):PostfixUnaryExpressionSyntax;
	function elementAccessExpression(expression:IExpressionSyntax, openBracketToken:ISyntaxToken, argumentExpression:IExpressionSyntax, closeBracketToken:ISyntaxToken):ElementAccessExpressionSyntax;
	function invocationExpression(expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):InvocationExpressionSyntax;
	function argumentList(typeArgumentList:TypeArgumentListSyntax, openParenToken:ISyntaxToken, _arguments:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ArgumentListSyntax;
	function binaryExpression(kind:SyntaxKind, left:IExpressionSyntax, operatorToken:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	function conditionalExpression(condition:IExpressionSyntax, questionToken:ISyntaxToken, whenTrue:IExpressionSyntax, colonToken:ISyntaxToken, whenFalse:IExpressionSyntax):ConditionalExpressionSyntax;
	function constructSignature(newKeyword:ISyntaxToken, callSignature:CallSignatureSyntax):ConstructSignatureSyntax;
	function methodSignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, callSignature:CallSignatureSyntax):MethodSignatureSyntax;
	function indexSignature(openBracketToken:ISyntaxToken, parameter:ParameterSyntax, closeBracketToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):IndexSignatureSyntax;
	function propertySignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):PropertySignatureSyntax;
	function callSignature(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax):CallSignatureSyntax;
	function parameterList(openParenToken:ISyntaxToken, parameters:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ParameterListSyntax;
	function typeParameterList(lessThanToken:ISyntaxToken, typeParameters:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeParameterListSyntax;
	function typeParameter(identifier:ISyntaxToken, constraint:ConstraintSyntax):TypeParameterSyntax;
	function constraint(extendsKeyword:ISyntaxToken, type:ITypeSyntax):ConstraintSyntax;
	function elseClause(elseKeyword:ISyntaxToken, statement:IStatementSyntax):ElseClauseSyntax;
	function ifStatement(ifKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax, elseClause:ElseClauseSyntax):IfStatementSyntax;
	function expressionStatement(expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ExpressionStatementSyntax;
	function constructorDeclaration(modifiers:ISyntaxList, constructorKeyword:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):ConstructorDeclarationSyntax;
	function memberFunctionDeclaration(modifiers:ISyntaxList, propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):MemberFunctionDeclarationSyntax;
	function getAccessor(modifiers:ISyntaxList, getKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax, block:BlockSyntax):GetAccessorSyntax;
	function setAccessor(modifiers:ISyntaxList, setKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, block:BlockSyntax):SetAccessorSyntax;
	function memberVariableDeclaration(modifiers:ISyntaxList, variableDeclarator:VariableDeclaratorSyntax, semicolonToken:ISyntaxToken):MemberVariableDeclarationSyntax;
	function indexMemberDeclaration(modifiers:ISyntaxList, indexSignature:IndexSignatureSyntax, semicolonToken:ISyntaxToken):IndexMemberDeclarationSyntax;
	function throwStatement(throwKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ThrowStatementSyntax;
	function returnStatement(returnKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ReturnStatementSyntax;
	function objectCreationExpression(newKeyword:ISyntaxToken, expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):ObjectCreationExpressionSyntax;
	function switchStatement(switchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, openBraceToken:ISyntaxToken, switchClauses:ISyntaxList, closeBraceToken:ISyntaxToken):SwitchStatementSyntax;
	function caseSwitchClause(caseKeyword:ISyntaxToken, expression:IExpressionSyntax, colonToken:ISyntaxToken, statements:ISyntaxList):CaseSwitchClauseSyntax;
	function defaultSwitchClause(defaultKeyword:ISyntaxToken, colonToken:ISyntaxToken, statements:ISyntaxList):DefaultSwitchClauseSyntax;
	function breakStatement(breakKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):BreakStatementSyntax;
	function continueStatement(continueKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ContinueStatementSyntax;
	function forStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, initializer:IExpressionSyntax, firstSemicolonToken:ISyntaxToken, condition:IExpressionSyntax, secondSemicolonToken:ISyntaxToken, incrementor:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForStatementSyntax;
	function forInStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, left:IExpressionSyntax, inKeyword:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForInStatementSyntax;
	function whileStatement(whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WhileStatementSyntax;
	function withStatement(withKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WithStatementSyntax;
	function enumDeclaration(modifiers:ISyntaxList, enumKeyword:ISyntaxToken, identifier:ISyntaxToken, openBraceToken:ISyntaxToken, enumElements:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):EnumDeclarationSyntax;
	function enumElement(propertyName:ISyntaxToken, equalsValueClause:EqualsValueClauseSyntax):EnumElementSyntax;
	function castExpression(lessThanToken:ISyntaxToken, type:ITypeSyntax, greaterThanToken:ISyntaxToken, expression:IUnaryExpressionSyntax):CastExpressionSyntax;
	function objectLiteralExpression(openBraceToken:ISyntaxToken, propertyAssignments:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectLiteralExpressionSyntax;
	function simplePropertyAssignment(propertyName:ISyntaxToken, colonToken:ISyntaxToken, expression:IExpressionSyntax):SimplePropertyAssignmentSyntax;
	function functionPropertyAssignment(propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionPropertyAssignmentSyntax;
	function functionExpression(functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionExpressionSyntax;
	function emptyStatement(semicolonToken:ISyntaxToken):EmptyStatementSyntax;
	function tryStatement(tryKeyword:ISyntaxToken, block:BlockSyntax, catchClause:CatchClauseSyntax, finallyClause:FinallyClauseSyntax):TryStatementSyntax;
	function catchClause(catchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, identifier:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, closeParenToken:ISyntaxToken, block:BlockSyntax):CatchClauseSyntax;
	function finallyClause(finallyKeyword:ISyntaxToken, block:BlockSyntax):FinallyClauseSyntax;
	function labeledStatement(identifier:ISyntaxToken, colonToken:ISyntaxToken, statement:IStatementSyntax):LabeledStatementSyntax;
	function doStatement(doKeyword:ISyntaxToken, statement:IStatementSyntax, whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, semicolonToken:ISyntaxToken):DoStatementSyntax;
	function typeOfExpression(typeOfKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):TypeOfExpressionSyntax;
	function deleteExpression(deleteKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):DeleteExpressionSyntax;
	function voidExpression(voidKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):VoidExpressionSyntax;
	function debuggerStatement(debuggerKeyword:ISyntaxToken, semicolonToken:ISyntaxToken):DebuggerStatementSyntax;
}
extern class StrictModeFactory {
	function sourceUnit(moduleElements:ISyntaxList, endOfFileToken:ISyntaxToken):SourceUnitSyntax;
	function externalModuleReference(requireKeyword:ISyntaxToken, openParenToken:ISyntaxToken, stringLiteral:ISyntaxToken, closeParenToken:ISyntaxToken):ExternalModuleReferenceSyntax;
	function moduleNameModuleReference(moduleName:INameSyntax):ModuleNameModuleReferenceSyntax;
	function importDeclaration(modifiers:ISyntaxList, importKeyword:ISyntaxToken, identifier:ISyntaxToken, equalsToken:ISyntaxToken, moduleReference:IModuleReferenceSyntax, semicolonToken:ISyntaxToken):ImportDeclarationSyntax;
	function exportAssignment(exportKeyword:ISyntaxToken, equalsToken:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ExportAssignmentSyntax;
	function classDeclaration(modifiers:ISyntaxList, classKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, openBraceToken:ISyntaxToken, classElements:ISyntaxList, closeBraceToken:ISyntaxToken):ClassDeclarationSyntax;
	function interfaceDeclaration(modifiers:ISyntaxList, interfaceKeyword:ISyntaxToken, identifier:ISyntaxToken, typeParameterList:TypeParameterListSyntax, heritageClauses:ISyntaxList, body:ObjectTypeSyntax):InterfaceDeclarationSyntax;
	function heritageClause(kind:SyntaxKind, extendsOrImplementsKeyword:ISyntaxToken, typeNames:ISeparatedSyntaxList):HeritageClauseSyntax;
	function moduleDeclaration(modifiers:ISyntaxList, moduleKeyword:ISyntaxToken, name:INameSyntax, stringLiteral:ISyntaxToken, openBraceToken:ISyntaxToken, moduleElements:ISyntaxList, closeBraceToken:ISyntaxToken):ModuleDeclarationSyntax;
	function functionDeclaration(modifiers:ISyntaxList, functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):FunctionDeclarationSyntax;
	function variableStatement(modifiers:ISyntaxList, variableDeclaration:VariableDeclarationSyntax, semicolonToken:ISyntaxToken):VariableStatementSyntax;
	function variableDeclaration(varKeyword:ISyntaxToken, variableDeclarators:ISeparatedSyntaxList):VariableDeclarationSyntax;
	function variableDeclarator(propertyName:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):VariableDeclaratorSyntax;
	function equalsValueClause(equalsToken:ISyntaxToken, value:IExpressionSyntax):EqualsValueClauseSyntax;
	function prefixUnaryExpression(kind:SyntaxKind, operatorToken:ISyntaxToken, operand:IUnaryExpressionSyntax):PrefixUnaryExpressionSyntax;
	function arrayLiteralExpression(openBracketToken:ISyntaxToken, expressions:ISeparatedSyntaxList, closeBracketToken:ISyntaxToken):ArrayLiteralExpressionSyntax;
	function omittedExpression():OmittedExpressionSyntax;
	function parenthesizedExpression(openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken):ParenthesizedExpressionSyntax;
	function simpleArrowFunctionExpression(identifier:ISyntaxToken, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):SimpleArrowFunctionExpressionSyntax;
	function parenthesizedArrowFunctionExpression(callSignature:CallSignatureSyntax, equalsGreaterThanToken:ISyntaxToken, block:BlockSyntax, expression:IExpressionSyntax):ParenthesizedArrowFunctionExpressionSyntax;
	function qualifiedName(left:INameSyntax, dotToken:ISyntaxToken, right:ISyntaxToken):QualifiedNameSyntax;
	function typeArgumentList(lessThanToken:ISyntaxToken, typeArguments:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeArgumentListSyntax;
	function constructorType(newKeyword:ISyntaxToken, typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):ConstructorTypeSyntax;
	function functionType(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, equalsGreaterThanToken:ISyntaxToken, type:ITypeSyntax):FunctionTypeSyntax;
	function objectType(openBraceToken:ISyntaxToken, typeMembers:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectTypeSyntax;
	function arrayType(type:ITypeSyntax, openBracketToken:ISyntaxToken, closeBracketToken:ISyntaxToken):ArrayTypeSyntax;
	function genericType(name:INameSyntax, typeArgumentList:TypeArgumentListSyntax):GenericTypeSyntax;
	function typeQuery(typeOfKeyword:ISyntaxToken, name:INameSyntax):TypeQuerySyntax;
	function typeAnnotation(colonToken:ISyntaxToken, type:ITypeSyntax):TypeAnnotationSyntax;
	function block(openBraceToken:ISyntaxToken, statements:ISyntaxList, closeBraceToken:ISyntaxToken):BlockSyntax;
	function parameter(dotDotDotToken:ISyntaxToken, modifiers:ISyntaxList, identifier:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, equalsValueClause:EqualsValueClauseSyntax):ParameterSyntax;
	function memberAccessExpression(expression:IExpressionSyntax, dotToken:ISyntaxToken, name:ISyntaxToken):MemberAccessExpressionSyntax;
	function postfixUnaryExpression(kind:SyntaxKind, operand:IMemberExpressionSyntax, operatorToken:ISyntaxToken):PostfixUnaryExpressionSyntax;
	function elementAccessExpression(expression:IExpressionSyntax, openBracketToken:ISyntaxToken, argumentExpression:IExpressionSyntax, closeBracketToken:ISyntaxToken):ElementAccessExpressionSyntax;
	function invocationExpression(expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):InvocationExpressionSyntax;
	function argumentList(typeArgumentList:TypeArgumentListSyntax, openParenToken:ISyntaxToken, _arguments:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ArgumentListSyntax;
	function binaryExpression(kind:SyntaxKind, left:IExpressionSyntax, operatorToken:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	function conditionalExpression(condition:IExpressionSyntax, questionToken:ISyntaxToken, whenTrue:IExpressionSyntax, colonToken:ISyntaxToken, whenFalse:IExpressionSyntax):ConditionalExpressionSyntax;
	function constructSignature(newKeyword:ISyntaxToken, callSignature:CallSignatureSyntax):ConstructSignatureSyntax;
	function methodSignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, callSignature:CallSignatureSyntax):MethodSignatureSyntax;
	function indexSignature(openBracketToken:ISyntaxToken, parameter:ParameterSyntax, closeBracketToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):IndexSignatureSyntax;
	function propertySignature(propertyName:ISyntaxToken, questionToken:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax):PropertySignatureSyntax;
	function callSignature(typeParameterList:TypeParameterListSyntax, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax):CallSignatureSyntax;
	function parameterList(openParenToken:ISyntaxToken, parameters:ISeparatedSyntaxList, closeParenToken:ISyntaxToken):ParameterListSyntax;
	function typeParameterList(lessThanToken:ISyntaxToken, typeParameters:ISeparatedSyntaxList, greaterThanToken:ISyntaxToken):TypeParameterListSyntax;
	function typeParameter(identifier:ISyntaxToken, constraint:ConstraintSyntax):TypeParameterSyntax;
	function constraint(extendsKeyword:ISyntaxToken, type:ITypeSyntax):ConstraintSyntax;
	function elseClause(elseKeyword:ISyntaxToken, statement:IStatementSyntax):ElseClauseSyntax;
	function ifStatement(ifKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax, elseClause:ElseClauseSyntax):IfStatementSyntax;
	function expressionStatement(expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ExpressionStatementSyntax;
	function constructorDeclaration(modifiers:ISyntaxList, constructorKeyword:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):ConstructorDeclarationSyntax;
	function memberFunctionDeclaration(modifiers:ISyntaxList, propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax, semicolonToken:ISyntaxToken):MemberFunctionDeclarationSyntax;
	function getAccessor(modifiers:ISyntaxList, getKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, typeAnnotation:TypeAnnotationSyntax, block:BlockSyntax):GetAccessorSyntax;
	function setAccessor(modifiers:ISyntaxList, setKeyword:ISyntaxToken, propertyName:ISyntaxToken, parameterList:ParameterListSyntax, block:BlockSyntax):SetAccessorSyntax;
	function memberVariableDeclaration(modifiers:ISyntaxList, variableDeclarator:VariableDeclaratorSyntax, semicolonToken:ISyntaxToken):MemberVariableDeclarationSyntax;
	function indexMemberDeclaration(modifiers:ISyntaxList, indexSignature:IndexSignatureSyntax, semicolonToken:ISyntaxToken):IndexMemberDeclarationSyntax;
	function throwStatement(throwKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ThrowStatementSyntax;
	function returnStatement(returnKeyword:ISyntaxToken, expression:IExpressionSyntax, semicolonToken:ISyntaxToken):ReturnStatementSyntax;
	function objectCreationExpression(newKeyword:ISyntaxToken, expression:IMemberExpressionSyntax, argumentList:ArgumentListSyntax):ObjectCreationExpressionSyntax;
	function switchStatement(switchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, openBraceToken:ISyntaxToken, switchClauses:ISyntaxList, closeBraceToken:ISyntaxToken):SwitchStatementSyntax;
	function caseSwitchClause(caseKeyword:ISyntaxToken, expression:IExpressionSyntax, colonToken:ISyntaxToken, statements:ISyntaxList):CaseSwitchClauseSyntax;
	function defaultSwitchClause(defaultKeyword:ISyntaxToken, colonToken:ISyntaxToken, statements:ISyntaxList):DefaultSwitchClauseSyntax;
	function breakStatement(breakKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):BreakStatementSyntax;
	function continueStatement(continueKeyword:ISyntaxToken, identifier:ISyntaxToken, semicolonToken:ISyntaxToken):ContinueStatementSyntax;
	function forStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, initializer:IExpressionSyntax, firstSemicolonToken:ISyntaxToken, condition:IExpressionSyntax, secondSemicolonToken:ISyntaxToken, incrementor:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForStatementSyntax;
	function forInStatement(forKeyword:ISyntaxToken, openParenToken:ISyntaxToken, variableDeclaration:VariableDeclarationSyntax, left:IExpressionSyntax, inKeyword:ISyntaxToken, expression:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):ForInStatementSyntax;
	function whileStatement(whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WhileStatementSyntax;
	function withStatement(withKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, statement:IStatementSyntax):WithStatementSyntax;
	function enumDeclaration(modifiers:ISyntaxList, enumKeyword:ISyntaxToken, identifier:ISyntaxToken, openBraceToken:ISyntaxToken, enumElements:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):EnumDeclarationSyntax;
	function enumElement(propertyName:ISyntaxToken, equalsValueClause:EqualsValueClauseSyntax):EnumElementSyntax;
	function castExpression(lessThanToken:ISyntaxToken, type:ITypeSyntax, greaterThanToken:ISyntaxToken, expression:IUnaryExpressionSyntax):CastExpressionSyntax;
	function objectLiteralExpression(openBraceToken:ISyntaxToken, propertyAssignments:ISeparatedSyntaxList, closeBraceToken:ISyntaxToken):ObjectLiteralExpressionSyntax;
	function simplePropertyAssignment(propertyName:ISyntaxToken, colonToken:ISyntaxToken, expression:IExpressionSyntax):SimplePropertyAssignmentSyntax;
	function functionPropertyAssignment(propertyName:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionPropertyAssignmentSyntax;
	function functionExpression(functionKeyword:ISyntaxToken, identifier:ISyntaxToken, callSignature:CallSignatureSyntax, block:BlockSyntax):FunctionExpressionSyntax;
	function emptyStatement(semicolonToken:ISyntaxToken):EmptyStatementSyntax;
	function tryStatement(tryKeyword:ISyntaxToken, block:BlockSyntax, catchClause:CatchClauseSyntax, finallyClause:FinallyClauseSyntax):TryStatementSyntax;
	function catchClause(catchKeyword:ISyntaxToken, openParenToken:ISyntaxToken, identifier:ISyntaxToken, typeAnnotation:TypeAnnotationSyntax, closeParenToken:ISyntaxToken, block:BlockSyntax):CatchClauseSyntax;
	function finallyClause(finallyKeyword:ISyntaxToken, block:BlockSyntax):FinallyClauseSyntax;
	function labeledStatement(identifier:ISyntaxToken, colonToken:ISyntaxToken, statement:IStatementSyntax):LabeledStatementSyntax;
	function doStatement(doKeyword:ISyntaxToken, statement:IStatementSyntax, whileKeyword:ISyntaxToken, openParenToken:ISyntaxToken, condition:IExpressionSyntax, closeParenToken:ISyntaxToken, semicolonToken:ISyntaxToken):DoStatementSyntax;
	function typeOfExpression(typeOfKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):TypeOfExpressionSyntax;
	function deleteExpression(deleteKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):DeleteExpressionSyntax;
	function voidExpression(voidKeyword:ISyntaxToken, expression:IUnaryExpressionSyntax):VoidExpressionSyntax;
	function debuggerStatement(debuggerKeyword:ISyntaxToken, semicolonToken:ISyntaxToken):DebuggerStatementSyntax;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class EmptySyntaxList {
	function kind():SyntaxKind;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function childCount():Float;
	function childAt(index:Float):ISyntaxNodeOrToken;
	function toArray():Array<ISyntaxNodeOrToken>;
	function collectTextElements(elements:Array<String>):Void;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function fullWidth():Float;
	function width():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function trailingTrivia():ISyntaxTriviaList;
	function leadingTriviaWidth():Float;
	function trailingTriviaWidth():Float;
	function fullText():String;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function findTokenInternal(parent:PositionedElement, position:Float, fullStart:Float):PositionedToken;
	function insertChildrenInto(array:Array<ISyntaxElement>, index:Float):Void;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class VariableWidthTokenWithNoTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	function new(fullText:String, kind:SyntaxKind):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class VariableWidthTokenWithLeadingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _leadingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, leadingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class VariableWidthTokenWithTrailingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _trailingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, trailingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class VariableWidthTokenWithLeadingAndTrailingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _leadingTriviaInfo : Dynamic;
	var _trailingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, leadingTriviaInfo:Float, trailingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class FixedWidthTokenWithNoTrivia {
	var tokenKind : SyntaxKind;
	function new(kind:SyntaxKind):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class FixedWidthTokenWithLeadingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _leadingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, leadingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class FixedWidthTokenWithTrailingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _trailingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, trailingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class FixedWidthTokenWithLeadingAndTrailingTrivia {
	var _fullText : Dynamic;
	var tokenKind : SyntaxKind;
	var _leadingTriviaInfo : Dynamic;
	var _trailingTriviaInfo : Dynamic;
	function new(fullText:String, kind:SyntaxKind, leadingTriviaInfo:Float, trailingTriviaInfo:Float):Void;
	function clone():ISyntaxToken;
	function isNode():Bool;
	function isToken():Bool;
	function isList():Bool;
	function isSeparatedList():Bool;
	function kind():SyntaxKind;
	function childCount():Float;
	function childAt(index:Float):ISyntaxElement;
	function fullWidth():Float;
	function width():Float;
	function text():String;
	function fullText():String;
	function value():Dynamic;
	function valueText():String;
	function hasLeadingTrivia():Bool;
	function hasLeadingComment():Bool;
	function hasLeadingNewLine():Bool;
	function hasLeadingSkippedText():Bool;
	function leadingTriviaWidth():Float;
	function leadingTrivia():ISyntaxTriviaList;
	function hasTrailingTrivia():Bool;
	function hasTrailingComment():Bool;
	function hasTrailingNewLine():Bool;
	function hasTrailingSkippedText():Bool;
	function trailingTriviaWidth():Float;
	function trailingTrivia():ISyntaxTriviaList;
	function hasSkippedToken():Bool;
	function toJSON(key:Dynamic):Dynamic;
	function firstToken():ISyntaxToken;
	function lastToken():ISyntaxToken;
	function isTypeScriptSpecific():Bool;
	function isIncrementallyUnusable():Bool;
	function accept(visitor:ISyntaxVisitor):Dynamic;
	function realize():Dynamic;
	function collectTextElements(elements:Array<String>):Void;
	function findTokenInternal(parent:Dynamic, position:Dynamic, fullStart:Dynamic):Dynamic;
	function withLeadingTrivia(leadingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function withTrailingTrivia(trailingTrivia:ISyntaxTriviaList):ISyntaxToken;
	function isExpression():Bool;
	function isPrimaryExpression():Bool;
	function isMemberExpression():Bool;
	function isPostfixExpression():Bool;
	function isUnaryExpression():Bool;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
extern class TypeScript.SyntaxTopLevel {
	static var emptySeparatedList : ISeparatedSyntaxList;
	static function separatedList(nodes:Array<ISyntaxNodeOrToken>):ISeparatedSyntaxList;
	static function emptySourceUnit():SourceUnitSyntax;
	static function getStandaloneExpression(positionedToken:PositionedToken):PositionedNodeOrToken;
	static function isInModuleOrTypeContext(positionedToken:PositionedToken):Bool;
	static function isInTypeOnlyContext(positionedToken:PositionedToken):Bool;
	static function childOffset(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function childOffsetAt(parent:ISyntaxElement, index:Float):Float;
	static function childIndex(parent:ISyntaxElement, child:ISyntaxElement):Float;
	static function nodeStructuralEquals(node1:SyntaxNode, node2:SyntaxNode):Bool;
	static function nodeOrTokenStructuralEquals(node1:ISyntaxNodeOrToken, node2:ISyntaxNodeOrToken):Bool;
	static function tokenStructuralEquals(token1:ISyntaxToken, token2:ISyntaxToken):Bool;
	static function triviaListStructuralEquals(triviaList1:ISyntaxTriviaList, triviaList2:ISyntaxTriviaList):Bool;
	static function triviaStructuralEquals(trivia1:ISyntaxTrivia, trivia2:ISyntaxTrivia):Bool;
	static function listStructuralEquals(list1:ISyntaxList, list2:ISyntaxList):Bool;
	static function separatedListStructuralEquals(list1:ISeparatedSyntaxList, list2:ISeparatedSyntaxList):Bool;
	static function elementStructuralEquals(element1:ISyntaxElement, element2:ISyntaxElement):Bool;
	static function identifierName(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function trueExpression():IUnaryExpressionSyntax;
	static function falseExpression():IUnaryExpressionSyntax;
	static function numericLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function stringLiteralExpression(text:String):IUnaryExpressionSyntax;
	static function isSuperInvocationExpression(node:IExpressionSyntax):Bool;
	static function isSuperInvocationExpressionStatement(node:SyntaxNode):Bool;
	static function isSuperMemberAccessExpression(node:IExpressionSyntax):Bool;
	static function isSuperMemberAccessInvocationExpression(node:SyntaxNode):Bool;
	static function assignmentExpression(left:IExpressionSyntax, token:ISyntaxToken, right:IExpressionSyntax):BinaryExpressionSyntax;
	static function nodeHasSkippedOrMissingTokens(node:SyntaxNode):Bool;
	static function isUnterminatedStringLiteral(token:ISyntaxToken):Bool;
	static function isUnterminatedMultilineCommentTrivia(trivia:ISyntaxTrivia):Bool;
	static function isEntirelyInsideCommentTrivia(trivia:ISyntaxTrivia, fullStart:Float, position:Float):Bool;
	static function isEntirelyInsideComment(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit:SourceUnitSyntax, position:Float):Bool;
	static function findSkippedTokenInLeadingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInTrailingTriviaList(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenInPositionedToken(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function findSkippedTokenOnLeft(positionedToken:PositionedToken, position:Float):PositionedSkippedToken;
	static function getAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):PositionedElement;
	static function hasAncestorOfKind(positionedToken:PositionedElement, kind:SyntaxKind):Bool;
	static function isIntegerLiteral(expression:IExpressionSyntax):Bool;
	static var normalModeFactory : IFactory;
	static var strictModeFactory : IFactory;
	static var emptyList : ISyntaxList;
	static function list(nodes:Array<ISyntaxNodeOrToken>):ISyntaxList;
	static function isExpression(token:ISyntaxToken):Bool;
	static function realizeToken(token:ISyntaxToken):ISyntaxToken;
	static function convertToIdentifierName(token:ISyntaxToken):ISyntaxToken;
	static function tokenToJSON(token:ISyntaxToken):Dynamic;
	static function value(token:ISyntaxToken):Dynamic;
	static function massageEscapes(text:String):String;
	static function valueText(token:ISyntaxToken):String;
	static function emptyToken(kind:SyntaxKind):ISyntaxToken;
	static function token(kind:SyntaxKind, ?info:ITokenInfo):ISyntaxToken;
	static function identifier(text:String, ?info:ITokenInfo):ISyntaxToken;
	static function deferredTrivia(kind:SyntaxKind, text:ISimpleText, fullStart:Float, fullWidth:Float):ISyntaxTrivia;
	static function trivia(kind:SyntaxKind, text:String):ISyntaxTrivia;
	static function skippedTokenTrivia(token:ISyntaxToken):ISyntaxTrivia;
	static function spaces(count:Float):ISyntaxTrivia;
	static function whitespace(text:String):ISyntaxTrivia;
	static function multiLineComment(text:String):ISyntaxTrivia;
	static function singleLineComment(text:String):ISyntaxTrivia;
	static var spaceTrivia : ISyntaxTrivia;
	static var lineFeedTrivia : ISyntaxTrivia;
	static var carriageReturnTrivia : ISyntaxTrivia;
	static var carriageReturnLineFeedTrivia : ISyntaxTrivia;
	static function splitMultiLineCommentTriviaIntoMultipleLines(trivia:ISyntaxTrivia):Array<String>;
	static var emptyTriviaList : ISyntaxTriviaList;
	static function triviaList(trivia:Array<ISyntaxTrivia>):ISyntaxTriviaList;
	static var spaceTriviaList : ISyntaxTriviaList;
}
