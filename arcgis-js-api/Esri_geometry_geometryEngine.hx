extern class Esri_geometry_geometryEngineTopLevel {
	static var geometryEngine : { @:overload(function(geometry:Array<Geometry>, distance:Float, ?unit:Float, ?unionResults:Bool):Dynamic { })
	@:overload(function(geometry:Geometry, distance:Float, ?unit:Float, ?unionResults:Bool):Dynamic { })
	@:overload(function(geometry:Array<Geometry>, distance:Array<Float>, ?unit:Float, ?unionResults:Bool):Dynamic { })
	function buffer(geometry:Geometry, distance:Array<Float>, ?unit:Float, ?unionResults:Bool):Dynamic; function clip(geometry:Geometry, envelope:Extent):Geometry; function contains(geometry1:Geometry, geometry2:Geometry):Bool; @:overload(function(geometry:Array<Geometry>, ?merge:Bool):Dynamic { })
	function convexHull(geometry:Geometry, ?merge:Bool):Dynamic; function crosses(geometry1:Geometry, geometry2:Geometry):Bool; function cut(geometry:Geometry, cutter:Polyline):Array<Geometry>; function densify(geometry:Geometry, maxSegmentLength:Float, ?maxSegmentLengthUnit:Float):Geometry; @:overload(function(geometry:Array<Geometry>, subtractor:Geometry):Dynamic { })
	function difference(geometry:Geometry, subtractor:Geometry):Dynamic; function disjoint(geometry1:Geometry, geometry2:Geometry):Bool; function distance(geometry1:Geometry, geometry2:Geometry, ?distanceUnit:Float):Float; function equals(geometry1:Geometry, geometry2:Geometry):Bool; function extendedSpatialReferenceInfo(spatialReference:SpatialReference):Dynamic; function flipHorizontal(geometry:Geometry, ?flipOrigin:Point):Geometry; function flipVertical(geometry:Geometry, ?flipOrigin:Point):Geometry; function generalize(geometry:Geometry, maxDeviation:Float, ?removeDegenerateParts:Bool, ?maxDeviationUnit:Float):Geometry; function geodesicArea(geometry:Geometry, ?unit:Float):Float; @:overload(function(geometry:Array<Geometry>, distance:Float, ?unit:Float, ?unionResults:Bool):Dynamic { })
	@:overload(function(geometry:Geometry, distance:Float, ?unit:Float, ?unionResults:Bool):Dynamic { })
	@:overload(function(geometry:Array<Geometry>, distance:Array<Float>, ?unit:Float, ?unionResults:Bool):Dynamic { })
	function geodesicBuffer(geometry:Geometry, distance:Array<Float>, ?unit:Float, ?unionResults:Bool):Dynamic; function geodesicLength(geometry:Geometry, ?unit:Float):Float; @:overload(function(geometry:Array<Geometry>, intersector:Geometry):Dynamic { })
	function intersect(geometry:Geometry, intersector:Geometry):Dynamic; function intersects(geometry1:Geometry, geometry2:Geometry):Bool; function isSimple(geometry:Geometry):Bool; function nearestCoordinate(geometry:Geometry, inputPoint:Point):Dynamic; function nearestVertex(geometry:Geometry, inputPoint:Point):Dynamic; function nearestVertices(geometry:Geometry, inputPoint:Point, searchRadius:Float, maxVertexCountToReturn:Float):Array<Dynamic>; @:overload(function(geometry:Array<Geometry>, distance:Float, offsetUnit:Float, joinType:Float, ?bevelRatio:Float, ?flattenError:Float):Dynamic { })
	function offset(geometry:Geometry, distance:Float, offsetUnit:Float, joinType:Float, ?bevelRatio:Float, ?flattenError:Float):Dynamic; function overlaps(geometry1:Geometry, geometry2:Geometry):Bool; function planarArea(geometry:Geometry, ?unit:Float):Float; function planarLength(geometry:Geometry, unit:Float):Float; function relate(geometry1:Geometry, geometry2:Geometry, relation:String):Bool; function rotate(geometry:Geometry, angle:Float, ?rotationOrigin:Point):Geometry; function simplify(geometry:Geometry):Geometry; @:overload(function(leftGeometry:Array<Geometry>, rightGeometry:Geometry):Dynamic { })
	function symmetricDifference(leftGeometry:Geometry, rightGeometry:Geometry):Dynamic; function touches(geometry1:Geometry, geometry2:Geometry):Bool; function union(geometries:Array<Geometry>):Geometry; function within(geometry1:Geometry, geometry2:Geometry):Bool; };
}
