typedef IWorkspaceViewStatic = {
	function new():IWorkspaceView;
	var version : Float;
	var configDefaults : Dynamic;
	function content():Dynamic;
};
typedef IWorkspaceView = {
	>View,
	var fullScreen : Bool;
	function open(uri:String, options:Dynamic):Q.Promise<View>;
	function openSync(uri:String, ?options:Dynamic):Dynamic;
	function saveActivePaneItem():Dynamic;
	function saveActivePaneItemAs():Dynamic;
	function saveAll():Void;
	function destroyActivePaneItem():Dynamic;
	function destroyActivePane():Dynamic;
	function increaseFontSize():Void;
	function decreaseFontSize():Void;
	@:overload(function(view:View, args:Dynamic):Void { })
	function initialize(model:IWorkspace):Dynamic;
	var model : IWorkspace;
	var panes : IPaneContainerView;
	function getModel():IWorkspace;
	function installShellCommands():Dynamic;
	function handleFocus():Dynamic;
	function afterAttach(?onDom:Dynamic):Dynamic;
	function confirmClose():Bool;
	function updateTitle():Dynamic;
	function setTitle(title:String):Dynamic;
	function getEditorViews():Array<Dynamic>;
	function prependToTop(element:Dynamic):Dynamic;
	function appendToTop(element:Dynamic):Dynamic;
	function prependToBottom(element:Dynamic):Dynamic;
	function appendToBottom(element:Dynamic):Dynamic;
	function prependToLeft(element:Dynamic):Dynamic;
	function appendToLeft(element:Dynamic):Dynamic;
	function prependToRight(element:Dynamic):Dynamic;
	function appendToRight(element:Dynamic):Dynamic;
	function getActivePaneView():IPaneView;
	function getActiveView():View;
	function focusPreviousPaneView():Dynamic;
	function focusNextPaneView():Dynamic;
	function focusPaneViewAbove():Dynamic;
	function focusPaneViewBelow():Dynamic;
	function focusPaneViewOnLeft():Dynamic;
	function focusPaneViewOnRight():Dynamic;
	function eachPaneView(callback:IPaneView -> Dynamic):{ function off():Dynamic; };
	function getPaneViews():Array<IPaneView>;
	function eachEditorView(callback:Dynamic -> Dynamic):{ function off():Dynamic; };
	function beforeRemove():Dynamic;
	@:overload(function(eventName:String, selector:haxe.Constraints.Function, handler:haxe.Constraints.Function):Dynamic { })
	@:overload(function(eventName:String, options:Dynamic, handler:haxe.Constraints.Function):Dynamic { })
	@:overload(function(eventName:String, selector:haxe.Constraints.Function, options:Dynamic, handler:haxe.Constraints.Function):Dynamic { })
	function command(eventName:String, handler:haxe.Constraints.Function):Dynamic;
	var statusBar : StatusBar.IStatusBarView;
};
typedef IPanes = { };
typedef IPaneView = { };
typedef IPaneContainerView = { };
typedef ITreeView = { };
typedef IGutterViewStatic = {
	function new():IGutterView;
	function content():Dynamic;
};
typedef IGutterView = {
	>View,
	var firstScreenRow : Dynamic;
	var lastScreenRow : Dynamic;
	@:overload(function(view:View, args:Dynamic):Void { })
	function initialize():Void;
	function afterAttach(?onDom:Dynamic):Dynamic;
	function beforeRemove():Dynamic;
	function handleMouseEvents(e:JQueryMouseEventObject):Dynamic;
	function getEditorView():Dynamic;
	function getEditor():IEditor;
	function getLineNumberElements():HTMLCollection;
	function getLineNumberElementsForClass(klass:String):NodeList;
	function getLineNumberElement(bufferRow:Float):NodeList;
	function addClassToAllLines(klass:String):Bool;
	function removeClassFromAllLines(klass:String):Bool;
	function addClassToLine(bufferRow:Float, klass:String):Bool;
	function removeClassFromLine(bufferRow:Float, klass:String):Bool;
	function updateLineNumbers(changes:Array<Dynamic>, ?startScreenRow:Float, ?endScreenRow:Float):Dynamic;
	function prependLineElements(lineElements:Dynamic):Void;
	function appendLineElements(lineElements:Dynamic):Void;
	function removeLineElements(numberOfElements:Float):Void;
	function buildLineElements(startScreenRow:Dynamic, endScreenRow:Dynamic):Dynamic;
	function buildLineElementsHtml(startScreenRow:Dynamic, endScreenRow:Dynamic):Dynamic;
	function updateFoldableClasses(changes:Array<Dynamic>):Dynamic;
	function removeLineHighlights():Void;
	function addLineHighlight(row:Float, ?emptySelection:Bool):Dynamic;
	function highlightLines():Bool;
};
typedef ICommandPanel = { };
typedef IDisplayBufferStatic = {
	function new(?_arg:Dynamic):IDisplayBuffer;
};
typedef IDisplayBuffer = {
	var constructor : IDisplayBufferStatic;
	var verticalScrollMargin : Float;
	var horizontalScrollMargin : Float;
	var declaredPropertyValues : Dynamic;
	var tokenizedBuffer : ITokenizedBuffer;
	var buffer : TextBuffer.ITextBuffer;
	var charWidthsByScope : Dynamic;
	var markers : { };
	var foldsByMarkerId : Dynamic;
	var maxLineLength : Float;
	var screenLines : Array<ITokenizedLine>;
	var rowMap : Dynamic;
	var longestScreenRow : Float;
	var subscriptions : Array<Emissary.ISubscription>;
	var subscriptionsByObject : Dynamic;
	var behaviors : Dynamic;
	var subscriptionCounts : Dynamic;
	var eventHandlersByEventName : Dynamic;
	var pendingChangeEvent : Dynamic;
	var softWrap : Bool;
	function serializeParams():{ var id : Float; var softWrap : Bool; var editorWidthInChars : Float; var scrollTop : Float; var scrollLeft : Float; var tokenizedBuffer : Dynamic; };
	function deserializeParams(params:Dynamic):Dynamic;
	function copy():IDisplayBuffer;
	function updateAllScreenLines():Dynamic;
	function emitChanged(eventProperties:Dynamic, ?refreshMarkers:Bool):Dynamic;
	function updateWrappedScreenLines():Dynamic;
	function setVisible(visible:Dynamic):Dynamic;
	function getVerticalScrollMargin():Float;
	function setVerticalScrollMargin(verticalScrollMargin:Float):Float;
	function getHorizontalScrollMargin():Float;
	function setHorizontalScrollMargin(horizontalScrollMargin:Float):Float;
	function getHeight():Dynamic;
	function setHeight(height:Dynamic):Dynamic;
	function getWidth():Dynamic;
	function setWidth(newWidth:Dynamic):Dynamic;
	function getScrollTop():Float;
	function setScrollTop(scrollTop:Float):Float;
	function getScrollBottom():Float;
	function setScrollBottom(scrollBottom:Float):Float;
	function getScrollLeft():Float;
	function setScrollLeft(scrollLeft:Float):Float;
	function getScrollRight():Float;
	function setScrollRight(scrollRight:Float):Float;
	function getLineHeight():Dynamic;
	function setLineHeight(lineHeight:Dynamic):Dynamic;
	function getDefaultCharWidth():Dynamic;
	function setDefaultCharWidth(defaultCharWidth:Dynamic):Dynamic;
	function getScopedCharWidth(scopeNames:Dynamic, char:Dynamic):Dynamic;
	function getScopedCharWidths(scopeNames:Dynamic):Dynamic;
	function setScopedCharWidth(scopeNames:Dynamic, char:Dynamic, width:Dynamic):Dynamic;
	function setScopedCharWidths(scopeNames:Dynamic, charWidths:Dynamic):Dynamic;
	function clearScopedCharWidths():Dynamic;
	function getScrollHeight():Float;
	function getScrollWidth():Float;
	function getVisibleRowRange():Array<Float>;
	function intersectsVisibleRowRange(startRow:Dynamic, endRow:Dynamic):Dynamic;
	function selectionIntersectsVisibleRowRange(selection:Dynamic):Dynamic;
	function scrollToScreenRange(screenRange:Dynamic):Dynamic;
	function scrollToScreenPosition(screenPosition:Dynamic):Dynamic;
	function scrollToBufferPosition(bufferPosition:Dynamic):Dynamic;
	function pixelRectForScreenRange(screenRange:TextBuffer.IRange):Dynamic;
	function getTabLength():Float;
	function setTabLength(tabLength:Float):Dynamic;
	function setSoftWrap(softWrap:Bool):Bool;
	function getSoftWrap():Bool;
	function setEditorWidthInChars(editorWidthInChars:Float):Dynamic;
	function getEditorWidthInChars():Float;
	function getSoftWrapColumn():Float;
	function lineForRow(row:Float):Dynamic;
	function linesForRows(startRow:Float, endRow:Float):Dynamic;
	function getLines():Array<Dynamic>;
	function indentLevelForLine(line:Dynamic):Dynamic;
	function bufferRowsForScreenRows(startScreenRow:Dynamic, endScreenRow:Dynamic):Dynamic;
	function createFold(startRow:Float, endRow:Float):IFold;
	function isFoldedAtBufferRow(bufferRow:Float):Bool;
	function isFoldedAtScreenRow(screenRow:Float):Bool;
	function destroyFoldWithId(id:Float):Dynamic;
	function unfoldBufferRow(bufferRow:Float):Array<Dynamic>;
	function largestFoldStartingAtBufferRow(bufferRow:Float):Dynamic;
	function foldsStartingAtBufferRow(bufferRow:Float):Dynamic;
	function largestFoldStartingAtScreenRow(screenRow:Dynamic):Dynamic;
	function largestFoldContainingBufferRow(bufferRow:Dynamic):Dynamic;
	function outermostFoldsInBufferRowRange(startRow:Dynamic, endRow:Dynamic):Array<Dynamic>;
	function foldsContainingBufferRow(bufferRow:Dynamic):Array<Dynamic>;
	function screenRowForBufferRow(bufferRow:Float):Float;
	function lastScreenRowForBufferRow(bufferRow:Float):Float;
	function bufferRowForScreenRow(screenRow:Float):Float;
	@:overload(function(bufferRange:TextBuffer.IRange):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : TextBuffer.IPoint; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : Array<Float>; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : { var row : Float; var col : Float; }; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : TextBuffer.IPoint; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : Array<Float>; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : { var row : Float; var col : Float; }; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : TextBuffer.IPoint; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : Array<Float>; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	@:overload(function(bufferRange:{ var start : { var row : Float; var col : Float; }; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	function screenRangeForBufferRange(bufferRange:Array<TextBuffer.IPoint>):TextBuffer.IRange;
	@:overload(function(screenRange:TextBuffer.IRange):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : TextBuffer.IPoint; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : Array<Float>; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : { var row : Float; var col : Float; }; }):TextBuffer.IRange { })
	function bufferRangeForScreenRange(screenRange:Array<TextBuffer.IPoint>):TextBuffer.IRange;
	@:overload(function(screenRange:TextBuffer.IRange, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : TextBuffer.IPoint; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : TextBuffer.IPoint; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : TextBuffer.IPoint; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : Array<Float>; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : Array<Float>; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : Array<Float>; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : TextBuffer.IPoint; var end : { var row : Float; var col : Float; }; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : Array<Float>; var end : { var row : Float; var col : Float; }; }, ?clip:Bool):TextBuffer.IRange { })
	@:overload(function(screenRange:{ var start : { var row : Float; var col : Float; }; var end : { var row : Float; var col : Float; }; }, ?clip:Bool):TextBuffer.IRange { })
	function pixelRangeForScreenRange(screenRange:Array<TextBuffer.IPoint>, ?clip:Bool):TextBuffer.IRange;
	@:overload(function(screenPosition:Array<Float>, ?clip:Bool):TextBuffer.IPoint { })
	@:overload(function(screenPosition:{ var row : Float; var col : Float; }, ?clip:Bool):TextBuffer.IPoint { })
	function pixelPositionForScreenPosition(screenPosition:TextBuffer.IPoint, ?clip:Bool):TextBuffer.IPoint;
	function screenPositionForPixelPosition(pixelPosition:Dynamic):TextBuffer.IPoint;
	function pixelPositionForBufferPosition(bufferPosition:Dynamic):Dynamic;
	function getLineCount():Float;
	function getLastRow():Float;
	function getMaxLineLength():Float;
	function screenPositionForBufferPosition(bufferPosition:Dynamic, options:Dynamic):Dynamic;
	function bufferPositionForScreenPosition(bufferPosition:Dynamic, options:Dynamic):Dynamic;
	function scopesForBufferPosition(bufferPosition:Dynamic):Dynamic;
	function bufferRangeForScopeAtPosition(selector:Dynamic, position:Dynamic):Dynamic;
	function tokenForBufferPosition(bufferPosition:Dynamic):Dynamic;
	function getGrammar():IGrammar;
	function setGrammar(grammar:IGrammar):Dynamic;
	function reloadGrammar():Dynamic;
	function clipScreenPosition(screenPosition:Dynamic, options:Dynamic):Dynamic;
	function findWrapColumn(line:Dynamic, softWrapColumn:Dynamic):Dynamic;
	function rangeForAllLines():TextBuffer.IRange;
	function getMarker(id:Float):IDisplayBufferMarker;
	function getMarkers():Array<IDisplayBufferMarker>;
	function getMarkerCount():Float;
	function markScreenRange(range:TextBuffer.IRange, args:haxe.extern.Rest<Dynamic>):IDisplayBufferMarker;
	function markBufferRange(range:TextBuffer.IRange, ?options:Dynamic):IDisplayBufferMarker;
	function markScreenPosition(screenPosition:TextBuffer.IPoint, ?options:Dynamic):IDisplayBufferMarker;
	function markBufferPosition(bufferPosition:TextBuffer.IPoint, ?options:Dynamic):IDisplayBufferMarker;
	function destroyMarker(id:Float):Dynamic;
	function findMarker(?params:Dynamic):IDisplayBufferMarker;
	function findMarkers(?params:Dynamic):Array<IDisplayBufferMarker>;
	function translateToBufferMarkerParams(?params:Dynamic):Dynamic;
	function findFoldMarker(attributes:Dynamic):IMarker;
	function findFoldMarkers(attributes:Dynamic):Array<IMarker>;
	function getFoldMarkerAttributes(?attributes:Dynamic):Dynamic;
	function pauseMarkerObservers():Dynamic;
	function resumeMarkerObservers():Dynamic;
	function refreshMarkerScreenPositions():Dynamic;
	function destroy():Dynamic;
	function logLines(start:Float, end:Float):Array<Dynamic>;
	function handleTokenizedBufferChange(tokenizedBufferChange:Dynamic):Dynamic;
	function updateScreenLines(startBufferRow:Dynamic, endBufferRow:Dynamic, ?bufferDelta:Float, ?options:Dynamic):Dynamic;
	function buildScreenLines(startBufferRow:Dynamic, endBufferRow:Dynamic):Dynamic;
	function findMaxLineLength(startScreenRow:Dynamic, endScreenRow:Dynamic, newScreenLines:Dynamic):Dynamic;
	function handleBufferMarkersUpdated():Dynamic;
	function handleBufferMarkerCreated(marker:Dynamic):Dynamic;
	function createFoldForMarker(maker:Dynamic):IFold;
	function foldForMarker(marker:Dynamic):Dynamic;
};
typedef ICursorStatic = {
	function new(arg:{ var editor : IEditor; var marker : IDisplayBufferMarker; var id : Float; }):ICursor;
};
typedef ICursor = {
	var screenPosition : Dynamic;
	var bufferPosition : Dynamic;
	var goalColumn : Dynamic;
	var visible : Bool;
	var needsAutoscroll : Bool;
	var editor : IEditor;
	var marker : IDisplayBufferMarker;
	var id : Float;
	function destroy():Dynamic;
	function changePosition(options:Dynamic, fn:haxe.Constraints.Function):Dynamic;
	function getPixelRect():Dynamic;
	function setScreenPosition(screenPosition:Dynamic, ?options:Dynamic):Dynamic;
	function getScreenPosition():TextBuffer.IPoint;
	function getScreenRange():TextBuffer.IRange;
	function setBufferPosition(bufferPosition:Dynamic, ?options:Dynamic):Dynamic;
	function getBufferPosition():TextBuffer.IPoint;
	function autoscroll():Dynamic;
	function updateVisibility():Dynamic;
	function setVisible(visible:Bool):Dynamic;
	function isVisible():Bool;
	function wordRegExp(?arg:Dynamic):Dynamic;
	function isLastCursor():Bool;
	function isSurroundedByWhitespace():Bool;
	function isBetweenWordAndNonWord():Bool;
	function isInsideWord():Bool;
	function clearAutoscroll():Void;
	function clearSelection():Void;
	function getScreenRow():Float;
	function getScreenColumn():Float;
	function getBufferRow():Float;
	function getBufferColumn():Float;
	function getCurrentBufferLine():String;
	function moveUp(rowCount:Float, ?arg:Dynamic):Dynamic;
	function moveDown(rowCount:Float, ?arg:Dynamic):Dynamic;
	function moveLeft(?arg:Dynamic):Dynamic;
	function moveRight(?arg:Dynamic):Dynamic;
	function moveToTop():Dynamic;
	function moveToBottom():Void;
	function moveToBeginningOfScreenLine():Void;
	function moveToBeginningOfLine():Void;
	function moveToFirstCharacterOfLine():Void;
	function moveToEndOfScreenLine():Void;
	function moveToEndOfLine():Void;
	function moveToBeginningOfWord():Void;
	function moveToEndOfWord():Void;
	function moveToBeginningOfNextWord():Void;
	function moveToPreviousWordBoundary():Void;
	function moveToNextWordBoundary():Void;
	function getBeginningOfCurrentWordBufferPosition(?options:Dynamic):TextBuffer.IPoint;
	function getPreviousWordBoundaryBufferPosition(?options:Dynamic):TextBuffer.IPoint;
	function getMoveNextWordBoundaryBufferPosition(?options:Dynamic):TextBuffer.IPoint;
	function getEndOfCurrentWordBufferPosition(?options:Dynamic):TextBuffer.IPoint;
	function getBeginningOfNextWordBufferPosition(?options:Dynamic):TextBuffer.IPoint;
	function getCurrentWordBufferRange(?options:Dynamic):TextBuffer.IPoint;
	function getCurrentLineBufferRange(?options:Dynamic):TextBuffer.IPoint;
	function getCurrentParagraphBufferRange():Dynamic;
	function getCurrentWordPrefix():String;
	function isAtBeginningOfLine():Bool;
	function getIndentLevel():Float;
	function isAtEndOfLine():Bool;
	function getScopes():Array<String>;
	function hasPrecedingCharactersOnLine():Bool;
};
typedef ILanguageMode = { };
typedef ISelection = {
	var cursor : ICursor;
	var marker : IDisplayBufferMarker;
	var editor : IEditor;
	var initialScreenRange : Dynamic;
	var wordwise : Bool;
	var needsAutoscroll : Bool;
	var retainSelection : Bool;
	var subscriptionCounts : Dynamic;
	function destroy():Dynamic;
	function finalize():Dynamic;
	function clearAutoscroll():Dynamic;
	function isEmpty():Bool;
	function isReversed():Bool;
	function isSingleScreenLine():Bool;
	function getScreenRange():TextBuffer.IRange;
	function setScreenRange(screenRange:Dynamic, options:Dynamic):Dynamic;
	function getBufferRange():TextBuffer.IRange;
	function setBufferRange(bufferRange:Dynamic, options:Dynamic):Dynamic;
	function getBufferRowRange():Array<Float>;
	function autoscroll():Void;
	function getText():String;
	function clear():Bool;
	function selectWord():TextBuffer.IRange;
	function expandOverWord():Dynamic;
	function selectLine(?row:Dynamic):TextBuffer.IRange;
	function expandOverLine():Bool;
	function selectToScreenPosition(position:Dynamic):Dynamic;
	function selectToBufferPosition(position:Dynamic):Dynamic;
	function selectRight():Bool;
	function selectLeft():Bool;
	function selectUp(?rowCount:Dynamic):Bool;
	function selectDown(?rowCount:Dynamic):Bool;
	function selectToTop():Dynamic;
	function selectToBottom():Dynamic;
	function selectAll():Dynamic;
	function selectToBeginningOfLine():Dynamic;
	function selectToFirstCharacterOfLine():Dynamic;
	function selectToEndOfLine():Dynamic;
	function selectToBeginningOfWord():Dynamic;
	function selectToEndOfWord():Dynamic;
	function selectToBeginningOfNextWord():Dynamic;
	function selectToPreviousWordBoundary():Dynamic;
	function selectToNextWordBoundary():Dynamic;
	function addSelectionBelow():Dynamic;
	function getGoalBufferRange():Dynamic;
	function addSelectionAbove():Array<Dynamic>;
	function insertText(text:String, ?options:Dynamic):Dynamic;
	function normalizeIndents(text:String, indentBasis:Float):Dynamic;
	function indent(?_arg:Dynamic):Dynamic;
	function indentSelectedRows():Array<TextBuffer.IRange>;
	function setIndentationForLine(line:String, indentLevel:Float):Dynamic;
	function backspace():Dynamic;
	function backspaceToBeginningOfWord():Dynamic;
	function backspaceToBeginningOfLine():Dynamic;
	function delete():Dynamic;
	function deleteToEndOfWord():Dynamic;
	function deleteSelectedText():Dynamic;
	function deleteLine():Dynamic;
	function joinLines():Dynamic;
	function outdentSelectedRows():Array<Dynamic>;
	function autoIndentSelectedRows():Dynamic;
	function toggleLineComments():Dynamic;
	function cutToEndOfLine(maintainClipboard:Dynamic):Dynamic;
	function cut(maintainClipboard:Dynamic):Dynamic;
	function copy(maintainClipboard:Dynamic):Dynamic;
	function fold():Dynamic;
	function modifySelection(fn:Void -> Dynamic):Dynamic;
	function plantTail():Dynamic;
	function intersectsBufferRange(bufferRange:Dynamic):Dynamic;
	function intersectsWith(otherSelection:Dynamic):Dynamic;
	function merge(otherSelection:Dynamic, options:Dynamic):Dynamic;
	function compare(otherSelection:Dynamic):Dynamic;
	function getRegionRects():Array<Dynamic>;
	function screenRangeChanged():Dynamic;
};
typedef IDecorationParams = {
	@:optional
	var id : Float;
	var class : String;
	var type : Dynamic;
};
typedef IDecorationStatic = {
	function isType(decorationParams:IDecorationParams, type:Dynamic):Bool;
	function new(marker:IDisplayBufferMarker, displayBuffer:IDisplayBuffer, params:IDecorationParams):IDecoration;
};
typedef IDecoration = {
	>Emissary.IEmitter,
	var marker : IDisplayBufferMarker;
	var displayBuffer : IDisplayBuffer;
	var params : IDecorationParams;
	var id : Float;
	var flashQueue : Array<Dynamic>;
	var isDestroyed : Bool;
	function destroy():Void;
	function update(newParams:IDecorationParams):Void;
	function getMarker():IDisplayBufferMarker;
	function getParams():IDecorationParams;
	function isType(type:String):Bool;
	function matchesPattern(decorationPattern:{ }):Bool;
	function flash(klass:String, ?duration:Float):Void;
	function consumeNextFlash():Dynamic;
};
typedef IEditor = {
	var deserializing : Bool;
	var callDisplayBufferCreatedHook : Bool;
	var registerEditor : Bool;
	var buffer : TextBuffer.ITextBuffer;
	var languageMode : ILanguageMode;
	var cursors : Array<ICursor>;
	var selections : Array<ISelection>;
	var suppressSelectionMerging : Bool;
	var updateBatchDepth : Float;
	var selectionFlashDuration : Float;
	var softTabs : Bool;
	var displayBuffer : IDisplayBuffer;
	var id : Float;
	var behaviors : Dynamic;
	var declaredPropertyValues : Dynamic;
	var eventHandlersByEventName : Dynamic;
	var eventHandlersByNamespace : Dynamic;
	var lastOpened : Float;
	var subscriptionCounts : Dynamic;
	var subscriptionsByObject : Dynamic;
	var subscriptions : Array<Emissary.ISubscription>;
	var mini : Dynamic;
	function serializeParams():{ var id : Float; var softTabs : Bool; var scrollTop : Float; var scrollLeft : Float; var displayBuffer : Dynamic; };
	function deserializeParams(params:Dynamic):Dynamic;
	function subscribeToBuffer():Void;
	function subscribeToDisplayBuffer():Void;
	function getViewClass():Dynamic;
	function destroyed():Void;
	function copy():IEditor;
	function getTitle():String;
	function getLongTitle():String;
	function setVisible(visible:Bool):Void;
	function setMini(mini:Dynamic):Void;
	function setEditorWidthInChars(editorWidthInChars:Dynamic):Void;
	function getSoftWrapColumn():Float;
	function getSoftTabs():Bool;
	function setSoftTabs(softTabs:Bool):Void;
	function getSoftWrap():Bool;
	function setSoftWrap(softWrap:Dynamic):Void;
	function getTabText():String;
	function getTabLength():Float;
	function setTabLength(tabLength:Dynamic):Void;
	function usesSoftTabs():Bool;
	function clipBufferPosition(bufferPosition:Dynamic):Void;
	function clipBufferRange(range:Dynamic):Void;
	function indentationForBufferRow(bufferRow:Dynamic):Void;
	function setIndentationForBufferRow(bufferRow:Dynamic, newLevel:Dynamic, _arg:Dynamic):Void;
	function indentLevelForLine(line:Dynamic):Float;
	function buildIndentString(number:Dynamic):String;
	function save():Void;
	function saveAs(filePath:Dynamic):Void;
	function copyPathToClipboard():Void;
	function getPath():String;
	function getText():String;
	function setText(text:Dynamic):Void;
	function getTextInRange(range:Dynamic):Dynamic;
	function getLineCount():Float;
	function getBuffer():TextBuffer.ITextBuffer;
	function getUri():String;
	function isBufferRowBlank(bufferRow:Dynamic):Bool;
	function isBufferRowCommented(bufferRow:Dynamic):Void;
	function nextNonBlankBufferRow(bufferRow:Dynamic):Void;
	function getEofBufferPosition():TextBuffer.IPoint;
	function getLastBufferRow():Float;
	function bufferRangeForBufferRow(row:Dynamic, options:Dynamic):TextBuffer.IRange;
	function lineForBufferRow(row:Float):String;
	function lineLengthForBufferRow(row:Float):Float;
	function scan():Dynamic;
	function scanInBufferRange():Dynamic;
	function backwardsScanInBufferRange():Dynamic;
	function isModified():Bool;
	function isEmpty():Bool;
	function shouldPromptToSave():Bool;
	function screenPositionForBufferPosition(bufferPosition:Dynamic, ?options:Dynamic):TextBuffer.IPoint;
	function bufferPositionForScreenPosition(screenPosition:Dynamic, ?options:Dynamic):TextBuffer.IPoint;
	function screenRangeForBufferRange(bufferRange:Dynamic):TextBuffer.IRange;
	function bufferRangeForScreenRange(screenRange:Dynamic):TextBuffer.IRange;
	function clipScreenPosition(screenPosition:Dynamic, options:Dynamic):TextBuffer.IRange;
	function lineForScreenRow(row:Dynamic):ITokenizedLine;
	function linesForScreenRows(?start:Dynamic, ?end:Dynamic):Array<ITokenizedLine>;
	function getScreenLineCount():Float;
	function getMaxScreenLineLength():Float;
	function getLastScreenRow():Float;
	function bufferRowsForScreenRows(startRow:Dynamic, endRow:Dynamic):Array<Dynamic>;
	function bufferRowForScreenRow(row:Dynamic):Float;
	function scopesForBufferPosition(bufferPosition:Dynamic):Array<String>;
	function bufferRangeForScopeAtCursor(selector:String):Dynamic;
	function tokenForBufferPosition(bufferPosition:Dynamic):IToken;
	function getCursorScopes():Array<String>;
	function logCursorScope():Void;
	function insertText(text:String, ?options:Dynamic):Array<TextBuffer.IRange>;
	function insertNewline():Array<TextBuffer.IRange>;
	function insertNewlineBelow():Array<TextBuffer.IRange>;
	function insertNewlineAbove():Dynamic;
	function indent(?options:Dynamic):Dynamic;
	function backspace():Array<Dynamic>;
	function deleteToBeginningOfWord():Array<Dynamic>;
	function deleteToBeginningOfLine():Array<Dynamic>;
	function delete():Array<Dynamic>;
	function deleteToEndOfLine():Array<Dynamic>;
	function deleteToEndOfWord():Array<Dynamic>;
	function deleteLine():Array<TextBuffer.IRange>;
	function indentSelectedRows():Array<Array<TextBuffer.IRange>>;
	function outdentSelectedRows():Array<Array<TextBuffer.IRange>>;
	function toggleLineCommentsInSelection():Array<TextBuffer.IRange>;
	function autoIndentSelectedRows():Array<Array<TextBuffer.IRange>>;
	function normalizeTabsInBufferRange(bufferRange:Dynamic):Dynamic;
	function cutToEndOfLine():Array<Bool>;
	function cutSelectedText():Array<Bool>;
	function copySelectedText():Array<Bool>;
	function pasteText(?options:Dynamic):Array<TextBuffer.IRange>;
	function undo():Array<Dynamic>;
	function redo():Array<Dynamic>;
	function foldCurrentRow():Dynamic;
	function unfoldCurrentRow():Array<Dynamic>;
	function foldSelectedLines():Array<Dynamic>;
	function foldAll():Array<Dynamic>;
	function unfoldAll():Array<Dynamic>;
	function foldAllAtIndentLevel(level:Dynamic):Dynamic;
	function foldBufferRow(bufferRow:Dynamic):Dynamic;
	function unfoldBufferRow(bufferRow:Dynamic):Dynamic;
	function isFoldableAtBufferRow(bufferRow:Dynamic):Bool;
	function isFoldableAtScreenRow(screenRow:Dynamic):Bool;
	function createFold(startRow:Dynamic, endRow:Dynamic):IFold;
	function destroyFoldWithId(id:Dynamic):Dynamic;
	function destroyFoldsIntersectingBufferRange(bufferRange:Dynamic):Dynamic;
	function toggleFoldAtBufferRow(bufferRow:Dynamic):Dynamic;
	function isFoldedAtCursorRow():Bool;
	function isFoldedAtBufferRow(bufferRow:Dynamic):Bool;
	function isFoldedAtScreenRow(screenRow:Dynamic):Bool;
	function largestFoldContainingBufferRow(bufferRow:Dynamic):Bool;
	function largestFoldStartingAtScreenRow(screenRow:Dynamic):Dynamic;
	function outermostFoldsInBufferRowRange(startRow:Dynamic, endRow:Dynamic):Array<Dynamic>;
	function moveLineUp():Array<ISelection>;
	function moveLineDown():Array<ISelection>;
	function duplicateLines():Array<Array<Dynamic>>;
	function mutateSelectedText(fn:ISelection -> Dynamic):Dynamic;
	function replaceSelectedText(options:Dynamic, fn:String -> Dynamic):Dynamic;
	function decorationsForScreenRowRange(startScreenRow:Dynamic, endScreenRow:Dynamic):{ };
	function decorateMarker(marker:IDisplayBufferMarker, decorationParams:{ var type : String; var class : String; }):IDecoration;
	function decorationForId(id:Float):IDecoration;
	function getMarker(id:Float):IDisplayBufferMarker;
	function getMarkers():Array<IDisplayBufferMarker>;
	function findMarkers(args:haxe.extern.Rest<Dynamic>):Array<IDisplayBufferMarker>;
	function markScreenRange(args:haxe.extern.Rest<Dynamic>):IDisplayBufferMarker;
	function markBufferRange(args:haxe.extern.Rest<Dynamic>):IDisplayBufferMarker;
	function markScreenPosition(args:haxe.extern.Rest<Dynamic>):IDisplayBufferMarker;
	function markBufferPosition(args:haxe.extern.Rest<Dynamic>):IDisplayBufferMarker;
	function destroyMarker(args:haxe.extern.Rest<Dynamic>):Bool;
	function getMarkerCount():Float;
	function hasMultipleCursors():Bool;
	function getCursors():Array<ICursor>;
	function getCursor():ICursor;
	function addCursorAtScreenPosition(screenPosition:Dynamic):ICursor;
	function addCursorAtBufferPosition(bufferPosition:Dynamic):ICursor;
	function addCursor(marker:Dynamic):ICursor;
	function removeCursor(cursor:Dynamic):Array<ICursor>;
	function addSelection(marker:Dynamic, options:Dynamic):ISelection;
	function addSelectionForBufferRange(bufferRange:Dynamic, options:Dynamic):ISelection;
	function setSelectedBufferRange(bufferRange:Dynamic, options:Dynamic):Dynamic;
	function setSelectedBufferRanges(bufferRanges:Dynamic, options:Dynamic):Dynamic;
	function removeSelection(selection:ISelection):Dynamic;
	function clearSelections():Bool;
	function consolidateSelections():Bool;
	function selectionScreenRangeChanged(selection:Dynamic):Void;
	function getSelections():Array<ISelection>;
	function getSelection(?index:Float):ISelection;
	function getLastSelection():ISelection;
	function getSelectionsOrderedByBufferPosition():Array<ISelection>;
	function getLastSelectionInBuffer():ISelection;
	function selectionIntersectsBufferRange(bufferRange:Dynamic):Dynamic;
	function setCursorScreenPosition(position:TextBuffer.IPoint, ?options:Dynamic):Dynamic;
	function getCursorScreenPosition():TextBuffer.IPoint;
	function getCursorScreenRow():Float;
	function setCursorBufferPosition(position:Dynamic, ?options:Dynamic):Dynamic;
	function getCursorBufferPosition():TextBuffer.IPoint;
	function getSelectedScreenRange():TextBuffer.IRange;
	function getSelectedBufferRange():TextBuffer.IRange;
	function getSelectedBufferRanges():Array<TextBuffer.IRange>;
	function getSelectedText():String;
	function getTextInBufferRange(range:TextBuffer.IRange):String;
	function setTextInBufferRange(range:TextBuffer.IRange, text:String):Dynamic;
	function getCurrentParagraphBufferRange():TextBuffer.IRange;
	function getWordUnderCursor(?options:Dynamic):String;
	function moveCursorUp(?lineCount:Float):Void;
	function moveCursorDown(?lineCount:Float):Void;
	function moveCursorLeft():Void;
	function moveCursorRight():Void;
	function moveCursorToTop():Void;
	function moveCursorToBottom():Void;
	function moveCursorToBeginningOfScreenLine():Void;
	function moveCursorToBeginningOfLine():Void;
	function moveCursorToFirstCharacterOfLine():Void;
	function moveCursorToEndOfScreenLine():Void;
	function moveCursorToEndOfLine():Void;
	function moveCursorToBeginningOfWord():Void;
	function moveCursorToEndOfWord():Void;
	function moveCursorToBeginningOfNextWord():Void;
	function moveCursorToPreviousWordBoundary():Void;
	function moveCursorToNextWordBoundary():Void;
	function moveCursorToBeginningOfNextParagraph():Void;
	function moveCursorToBeginningOfPreviousParagraph():Void;
	function scrollToCursorPosition(options:Dynamic):Dynamic;
	function pageUp():Void;
	function pageDown():Void;
	function selectPageUp():Void;
	function selectPageDown():Void;
	function getRowsPerPage():Float;
	function moveCursors(fn:ICursor -> Dynamic):Dynamic;
	function cursorMoved(event:Dynamic):Void;
	function selectToScreenPosition(position:TextBuffer.IPoint):Dynamic;
	function selectRight():Array<ISelection>;
	function selectLeft():Array<ISelection>;
	function selectUp(?rowCount:Float):Array<ISelection>;
	function selectDown(?rowCount:Float):Array<ISelection>;
	function selectToTop():Array<ISelection>;
	function selectAll():Array<ISelection>;
	function selectToBottom():Array<ISelection>;
	function selectToBeginningOfLine():Array<ISelection>;
	function selectToFirstCharacterOfLine():Array<ISelection>;
	function selectToEndOfLine():Array<ISelection>;
	function selectToPreviousWordBoundary():Array<ISelection>;
	function selectToNextWordBoundary():Array<ISelection>;
	function selectLine():Array<ISelection>;
	function addSelectionBelow():Array<ISelection>;
	function addSelectionAbove():Array<ISelection>;
	function splitSelectionsIntoLines():Array<Dynamic>;
	function transpose():Array<TextBuffer.IRange>;
	function upperCase():Array<Bool>;
	function lowerCase():Array<Bool>;
	function joinLines():Array<Dynamic>;
	function selectToBeginningOfWord():Array<ISelection>;
	function selectToEndOfWord():Array<ISelection>;
	function selectToBeginningOfNextWord():Array<ISelection>;
	function selectWord():Array<ISelection>;
	function selectToBeginningOfNextParagraph():Array<ISelection>;
	function selectToBeginningOfPreviousParagraph():Array<ISelection>;
	function selectMarker(marker:Dynamic):Dynamic;
	function mergeCursors():Array<Float>;
	function expandSelectionsForward():Dynamic;
	function expandSelectionsBackward(fn:ISelection -> Dynamic):Array<ISelection>;
	function finalizeSelections():Array<Bool>;
	function mergeIntersectingSelections():Dynamic;
	function preserveCursorPositionOnBufferReload():Emissary.ISubscription;
	function getGrammar():IGrammar;
	function setGrammar(grammer:IGrammar):Void;
	function reloadGrammar():Dynamic;
	function shouldAutoIndent():Bool;
	function shouldShowInvisibles():Bool;
	function updateInvisibles():Void;
	function transact(fn:haxe.Constraints.Function):Dynamic;
	function beginTransaction():ITransaction;
	function commitTransaction():Dynamic;
	function abortTransaction():Array<Dynamic>;
	function inspect():String;
	function logScreenLines(start:Float, end:Float):Array<Dynamic>;
	function handleTokenization():Void;
	function handleGrammarChange():Void;
	function handleMarkerCreated(marker:Dynamic):Dynamic;
	function getSelectionMarkerAttributes():{ var type : String; var editorId : Float; var invalidate : String; };
	function getVerticalScrollMargin():Float;
	function setVerticalScrollMargin(verticalScrollMargin:Float):Void;
	function getHorizontalScrollMargin():Float;
	function setHorizontalScrollMargin(horizontalScrollMargin:Float):Void;
	function getLineHeightInPixels():Float;
	function setLineHeightInPixels(lineHeightInPixels:Float):Void;
	function batchCharacterMeasurement(fn:haxe.Constraints.Function):Void;
	function getScopedCharWidth(scopeNames:Dynamic, char:Dynamic):Dynamic;
	function setScopedCharWidth(scopeNames:Dynamic, char:Dynamic, width:Dynamic):Dynamic;
	function getScopedCharWidths(scopeNames:Dynamic):Dynamic;
	function clearScopedCharWidths():Dynamic;
	function getDefaultCharWidth():Float;
	function setDefaultCharWidth(defaultCharWidth:Float):Void;
	function setHeight(height:Float):Void;
	function getHeight():Float;
	function getClientHeight():Float;
	function setWidth(width:Float):Void;
	function getWidth():Float;
	function getScrollTop():Float;
	function setScrollTop(scrollTop:Float):Void;
	function getScrollBottom():Float;
	function setScrollBottom(scrollBottom:Float):Void;
	function getScrollLeft():Float;
	function setScrollLeft(scrollLeft:Float):Void;
	function getScrollRight():Float;
	function setScrollRight(scrollRight:Float):Void;
	function getScrollHeight():Float;
	function getScrollWidth():Float;
	function getVisibleRowRange():Float;
	function intersectsVisibleRowRange(startRow:Dynamic, endRow:Dynamic):Dynamic;
	function selectionIntersectsVisibleRowRange(selection:Dynamic):Dynamic;
	function pixelPositionForScreenPosition(screenPosition:Dynamic):Dynamic;
	function pixelPositionForBufferPosition(bufferPosition:Dynamic):Dynamic;
	function screenPositionForPixelPosition(pixelPosition:Dynamic):Dynamic;
	function pixelRectForScreenRange(screenRange:Dynamic):Dynamic;
	function scrollToScreenRange(screenRange:Dynamic, options:Dynamic):Dynamic;
	function scrollToScreenPosition(screenPosition:Dynamic, options:Dynamic):Dynamic;
	function scrollToBufferPosition(bufferPosition:Dynamic, options:Dynamic):Dynamic;
	function horizontallyScrollable():Dynamic;
	function verticallyScrollable():Dynamic;
	function getHorizontalScrollbarHeight():Dynamic;
	function setHorizontalScrollbarHeight(height:Dynamic):Dynamic;
	function getVerticalScrollbarWidth():Dynamic;
	function setVerticalScrollbarWidth(width:Dynamic):Dynamic;
};
typedef IGrammar = {
	var scopeName : String;
};
typedef IPane = {
	var items : Array<Dynamic>;
	var activeItem : Dynamic;
	function serializeParams():Dynamic;
	function deserializeParams(params:Dynamic):Dynamic;
	function getViewClass():Dynamic;
	function isActive():Bool;
	function focus():Void;
	function blur():Void;
	function activate():Void;
	function getPanes():Array<IPane>;
	function getItems():Array<Dynamic>;
	function getActiveItem():Dynamic;
	function getActiveEditor():Dynamic;
	function itemAtIndex(index:Float):Dynamic;
	function activateNextItem():Dynamic;
	function activatePreviousItem():Dynamic;
	function getActiveItemIndex():Float;
	function activateItemAtIndex(index:Float):Dynamic;
	function activateItem(item:Dynamic):Dynamic;
	function addItem(item:Dynamic, index:Float):Dynamic;
	function addItems(items:Array<Dynamic>, index:Float):Array<Dynamic>;
	function removeItem(item:Dynamic, destroying:Dynamic):Void;
	function moveItem(item:Dynamic, newIndex:Float):Void;
	function moveItemToPane(item:Dynamic, pane:IPane, index:Float):Void;
	function destroyActiveItem():Bool;
	function destroyItem(item:Dynamic):Bool;
	function destroyItems():Array<Dynamic>;
	function destroyInactiveItems():Array<Dynamic>;
	function destroy():Void;
	function destroyed():Array<Dynamic>;
	function promptToSaveItem(item:Dynamic):Bool;
	function saveActiveItem():Void;
	function saveActiveItemAs():Void;
	function saveItem(item:Dynamic, nextAction:haxe.Constraints.Function):Void;
	function saveItemAs(item:Dynamic, nextAction:haxe.Constraints.Function):Void;
	function saveItems():Array<Dynamic>;
	function itemForUri(uri:Dynamic):Dynamic;
	function activateItemForUri(uri:Dynamic):Dynamic;
	function copyActiveItem():Void;
	function splitLeft(params:Dynamic):IPane;
	function splitRight(params:Dynamic):IPane;
	function splitUp(params:Dynamic):IPane;
	function splitDown(params:Dynamic):IPane;
	function split(orientation:String, side:String, params:Dynamic):IPane;
	function findLeftmostSibling():IPane;
	function findOrCreateRightmostSibling():IPane;
};
typedef ISerializationStatic<T> = {
	function deserialize(data:ISerializationInfo):T;
	function new(data:T):ISerialization;
};
typedef ISerialization = {
	function serialize():ISerializationInfo;
};
typedef ISerializationInfo = {
	var deserializer : String;
};
typedef IBrowserWindow = {
	function getPosition():Array<Float>;
	function getSize():Array<Float>;
};
typedef IAtomWindowDimentions = {
	var x : Float;
	var y : Float;
	var width : Float;
	var height : Float;
};
typedef IProjectStatic = {
	function pathForRepositoryUrl(repoUrl:String):String;
	function new(?arg:{ var path : Dynamic; var buffers : Array<Dynamic>; }):IProject;
};
typedef IProject = {
	var path : String;
	var rootDirectory : PathWatcher.IDirectory;
	function serializeParams():Dynamic;
	function deserializeParams(params:Dynamic):Dynamic;
	function destroyed():Dynamic;
	function destroyRepo():Dynamic;
	function destroyUnretainedBuffers():Dynamic;
	function getRepo():IGit;
	function getPath():String;
	function setPath(projectPath:String):Dynamic;
	function getRootDirectory():PathWatcher.IDirectory;
	function resolve(uri:String):String;
	function relativize(fullPath:String):String;
	function contains(pathToCheck:String):Bool;
	function open(filePath:String, ?options:Dynamic):Q.Promise<IEditor>;
	function openSync(filePath:String, ?options:Dynamic):IEditor;
	function getBuffers():TextBuffer.ITextBuffer;
	function isPathModified(filePath:String):Bool;
	function findBufferForPath(filePath:String):TextBuffer.ITextBuffer;
	function bufferForPathSync(filePath:String):TextBuffer.ITextBuffer;
	function bufferForPath(filePath:String):Q.Promise<TextBuffer.ITextBuffer>;
	function bufferForId(id:Dynamic):TextBuffer.ITextBuffer;
	function buildBufferSync(absoluteFilePath:String):TextBuffer.ITextBuffer;
	function buildBuffer(absoluteFilePath:String):Q.Promise<TextBuffer.ITextBuffer>;
	function addBuffer(buffer:TextBuffer.ITextBuffer, ?options:Dynamic):Dynamic;
	function addBufferAtIndex(buffer:TextBuffer.ITextBuffer, index:Float, ?options:Dynamic):Dynamic;
	function scan(regex:Dynamic, options:Dynamic, iterator:Dynamic):Q.Promise<Dynamic>;
	function replace(regex:Dynamic, replacementText:Dynamic, filePaths:Dynamic, iterator:Dynamic):Q.Promise<Dynamic>;
	function buildEditorForBuffer(buffer:Dynamic, editorOptions:Dynamic):IEditor;
	function eachBuffer(args:haxe.extern.Rest<Dynamic>):Dynamic;
};
typedef IWorkspaceStatic = {
	function new():IWorkspace;
};
typedef IWorkspace = {
	function deserializeParams(params:Dynamic):Dynamic;
	function serializeParams():{ var paneContainer : Dynamic; var fullScreen : Bool; };
	function eachEditor(callback:haxe.Constraints.Function):Void;
	function getEditors():Array<IEditor>;
	function open(uri:String, options:Dynamic):Q.Promise<View>;
	function openLicense():Void;
	function openSync(uri:String, options:Dynamic):Dynamic;
	function openUriInPane(uri:String, pane:Dynamic, options:Dynamic):Q.Promise<View>;
	function reopenItemSync():Dynamic;
	function registerOpener(opener:String -> Dynamic):Void;
	function unregisterOpener(opener:haxe.Constraints.Function):Void;
	function getOpeners():Dynamic;
	function getActivePane():IPane;
	function getPanes():Dynamic;
	function saveAll():Void;
	function activateNextPane():Dynamic;
	function activatePreviousPane():Dynamic;
	var paneForUri : String -> IPane;
	function saveActivePaneItem():Dynamic;
	function saveActivePaneItemAs():Dynamic;
	function destroyActivePaneItem():Dynamic;
	function destroyActivePane():Dynamic;
	function getActiveEditor():IEditor;
	function increaseFontSize():Void;
	function decreaseFontSize():Void;
	function resetFontSize():Void;
	function itemOpened(item:Dynamic):Void;
	function onPaneItemDestroyed(item:Dynamic):Void;
	function destroyed():Void;
};
typedef IAtomSettings = {
	var appVersion : String;
	var bootstrapScript : String;
	var devMode : Bool;
	var initialPath : String;
	var pathToOpen : String;
	var resourcePath : String;
	var shellLoadTime : Float;
	var windowState : String;
};
typedef IAtomState = {
	var mode : String;
	var packageStates : Dynamic;
	var project : Dynamic;
	var syntax : Dynamic;
	var version : Float;
	var windowDimensions : Dynamic;
	var workspace : Dynamic;
};
typedef IDeserializerManager = {
	var deserializers : haxe.Constraints.Function;
	var add : haxe.Constraints.Function;
	var remove : haxe.Constraints.Function;
	var deserialize : haxe.Constraints.Function;
	var get : haxe.Constraints.Function;
};
typedef IConfig = {
	function get(keyPath:String):Dynamic;
};
typedef IKeymapManager = {
	var defaultTarget : HTMLElement;
};
typedef IPackage = {
	var mainModulePath : String;
	var mainModule : Dynamic;
	function enable():Void;
	function disable():Void;
	function isTheme():Bool;
	function getType():String;
	function getStylesheetType():String;
	function load():IPackage;
	function reset():Void;
	function activate():Q.Promise<Array<Dynamic>>;
	function activateNow():Void;
};
typedef IPackageManager = {
	>Emissary.IEmitter,
	var packageDirPaths : Array<String>;
	var loadedPackages : Dynamic;
	var activePackages : Dynamic;
	var packageStates : Dynamic;
	var packageActivators : Array<Dynamic>;
	function getApmPath():String;
	function getPackageDirPaths():String;
	function getPackageState(name:String):Dynamic;
	function setPackageState(name:String, state:Dynamic):Void;
	function enablePackage(name:String):Dynamic;
	function disablePackage(name:String):Dynamic;
	function activate():Void;
	function registerPackageActivator(activator:Dynamic, types:Dynamic):Void;
	function activatePackages(packages:Dynamic):Void;
	function activatePackage(name:String):Q.Promise<IPackage>;
	function deactivatePackages():Void;
	function deactivatePackage(name:String):Void;
	function getActivePackages():Dynamic;
	function getActivePackage(name:String):Dynamic;
	function isPackageActive(name:String):Bool;
	function unobserveDisabledPackages():Void;
	function observeDisabledPackages():Void;
	function loadPackages():Void;
	function loadPackage(nameOrPath:String):Void;
	function unloadPackages():Void;
	function unloadPackage(name:String):Void;
	function getLoadedPackage(name:String):Dynamic;
	function isPackageLoaded(name:String):Bool;
	function getLoadedPackages():Dynamic;
	function getLoadedPackagesForTypes(types:Dynamic):Array<Dynamic>;
	function resolvePackagePath(name:String):String;
	function isPackageDisabled(name:String):Bool;
	function hasAtomEngine(packagePath:String):Bool;
	function isBundledPackage(name:String):Bool;
	function getPackageDependencies():Dynamic;
	function getAvailablePackagePaths():Array<Dynamic>;
	function getAvailablePackageNames():Array<Dynamic>;
	function getAvailablePackageMetadata():Array<Dynamic>;
};
typedef IThemeManager = { };
typedef IContextMenuManager = { };
typedef IMenuManager = { };
typedef IClipboard = { };
typedef ISyntax = { };
typedef IWindowEventHandler = { };
typedef IAtomStatic = {
	>ISerializationStatic<IAtom>,
	var version : Float;
	var loadSettings : IAtomSettings;
	@:overload(function(mode:Spec):IAtom { })
	@:overload(function(mode:String):IAtom { })
	function loadOrCreate(mode:Editor):IAtom;
	function loadState(mode:Dynamic):Void;
	function getStatePath(mode:Dynamic):String;
	function getConfigDirPath():String;
	function getStorageDirPath():String;
	function getLoadSettings():IAtomSettings;
	function getCurrentWindow():IBrowserWindow;
	function getVersion():String;
	function isReleasedVersion():Bool;
	function new(state:IAtomState):IAtom;
};
extern class Disposable {
	function new(disposalAction:Dynamic):Void;
	function dispose():Void;
}
extern class CommandRegistry {
	function add(target:String, commandName:String, callback:haxe.Constraints.Function):Disposable;
	function findCommands(params:Dynamic):Array<Dynamic>;
	function dispatch(target:Dynamic, commandName:String):Void;
}
typedef IAtom = {
	var constructor : IAtomStatic;
	var state : IAtomState;
	var mode : String;
	var deserializers : IDeserializerManager;
	var config : IConfig;
	var keymaps : IKeymapManager;
	var keymap : IKeymapManager;
	var packages : IPackageManager;
	var themes : IThemeManager;
	var contextManu : IContextMenuManager;
	var menu : IMenuManager;
	var clipboard : IClipboard;
	var syntax : ISyntax;
	var windowEventHandler : IWindowEventHandler;
	var subscribe : haxe.Constraints.Function;
	var unsubscribe : haxe.Constraints.Function;
	var loadTime : Float;
	var workspaceViewParentSelector : String;
	var project : IProject;
	var workspaceView : IWorkspaceView;
	var workspace : IWorkspace;
	var commands : CommandRegistry;
	var initialize : haxe.Constraints.Function;
	var setBodyPlatformClass : haxe.Constraints.Function;
	function getCurrentWindow():IBrowserWindow;
	var getWindowDimensions : haxe.Constraints.Function;
	var setWindowDimensions : haxe.Constraints.Function;
	var restoreWindowDimensions : haxe.Constraints.Function;
	var storeWindowDimensions : haxe.Constraints.Function;
	var getLoadSettings : haxe.Constraints.Function;
	var deserializeProject : haxe.Constraints.Function;
	var deserializeWorkspaceView : haxe.Constraints.Function;
	var deserializePackageStates : haxe.Constraints.Function;
	var deserializeEditorWindow : haxe.Constraints.Function;
	var startEditorWindow : haxe.Constraints.Function;
	var unloadEditorWindow : haxe.Constraints.Function;
	var loadThemes : haxe.Constraints.Function;
	var watchThemes : haxe.Constraints.Function;
	var open : haxe.Constraints.Function;
	var confirm : haxe.Constraints.Function;
	var showSaveDialog : haxe.Constraints.Function;
	var showSaveDialogSync : haxe.Constraints.Function;
	var openDevTools : haxe.Constraints.Function;
	var toggleDevTools : haxe.Constraints.Function;
	var executeJavaScriptInDevTools : haxe.Constraints.Function;
	var reload : haxe.Constraints.Function;
	var focus : haxe.Constraints.Function;
	var show : haxe.Constraints.Function;
	var hide : haxe.Constraints.Function;
	var setSize : haxe.Constraints.Function;
	var setPosition : haxe.Constraints.Function;
	var center : haxe.Constraints.Function;
	var displayWindow : haxe.Constraints.Function;
	var close : haxe.Constraints.Function;
	var exit : haxe.Constraints.Function;
	var inDevMode : haxe.Constraints.Function;
	var inSpecMode : haxe.Constraints.Function;
	var toggleFullScreen : haxe.Constraints.Function;
	var setFullScreen : haxe.Constraints.Function;
	var isFullScreen : haxe.Constraints.Function;
	var getVersion : haxe.Constraints.Function;
	var isReleasedVersion : haxe.Constraints.Function;
	var getGitHubAuthTokenName : haxe.Constraints.Function;
	var setGitHubAuthToken : haxe.Constraints.Function;
	var getGitHubAuthToken : haxe.Constraints.Function;
	var getConfigDirPath : haxe.Constraints.Function;
	var saveSync : haxe.Constraints.Function;
	function getWindowLoadTime():Float;
	var crashMainProcess : haxe.Constraints.Function;
	var crashRenderProcess : haxe.Constraints.Function;
	var beep : haxe.Constraints.Function;
	var getUserInitScriptPath : haxe.Constraints.Function;
	var requireUserInitScript : haxe.Constraints.Function;
	var requireWithGlobals : haxe.Constraints.Function;
};
typedef IBufferedNodeProcessStatic = {
	function new(arg:Dynamic):IBufferedNodeProcess;
};
typedef IBufferedNodeProcess = {
	>IBufferedProcess,
};
typedef IBufferedProcessStatic = {
	function new(arg:Dynamic):IBufferedProcess;
};
typedef IBufferedProcess = {
	var process : haxe.Constraints.Function;
	var killed : Bool;
	var bufferStream : haxe.Constraints.Function;
	var kill : haxe.Constraints.Function;
};
typedef IGitStatic = {
	function new(path:Dynamic, options:Dynamic):IGit;
};
typedef IGit = { };
typedef ITokenizedBuffer = { };
typedef ITokenizedLine = { };
typedef IToken = { };
typedef IFoldStatic = {
	function new(displayBuffer:IDisplayBuffer, marker:IMarker):IFold;
};
typedef IFold = {
	var id : Float;
	var displayBuffer : IDisplayBuffer;
	var marker : IMarker;
};
typedef IDisplayBufferMarkerStatic = {
	function new(_arg:{ var bufferMarker : IMarker; var displayBuffer : IDisplayBuffer; }):IDisplayBufferMarker;
};
typedef IDisplayBufferMarker = {
	>Emissary.IEmitter,
	>Emissary.ISubscriber,
	var constructor : IDisplayBufferMarkerStatic;
	var id : Float;
	var bufferMarkerSubscription : Dynamic;
	var oldHeadBufferPosition : TextBuffer.IPoint;
	var oldHeadScreenPosition : TextBuffer.IPoint;
	var oldTailBufferPosition : TextBuffer.IPoint;
	var oldTailScreenPosition : TextBuffer.IPoint;
	var wasValid : Bool;
	var bufferMarker : IMarker;
	var displayBuffer : IDisplayBuffer;
	var globalPauseCount : Float;
	var globalQueuedEvents : Dynamic;
	var subscriptions : Array<Emissary.ISubscription>;
	var subscriptionsByObject : Dynamic;
	function copy(?attributes:Dynamic):IDisplayBufferMarker;
	function getScreenRange():TextBuffer.IRange;
	function setScreenRange(screenRange:Dynamic, options:Dynamic):Dynamic;
	function getBufferRange():TextBuffer.IRange;
	function setBufferRange(bufferRange:Dynamic, options:Dynamic):Dynamic;
	function getPixelRange():Dynamic;
	function getHeadScreenPosition():TextBuffer.IPoint;
	function setHeadScreenPosition(screenPosition:Dynamic, options:Dynamic):Dynamic;
	function getHeadBufferPosition():TextBuffer.IPoint;
	function setHeadBufferPosition(bufferPosition:Dynamic):Dynamic;
	function getTailScreenPosition():TextBuffer.IPoint;
	function setTailScreenPosition(screenPosition:Dynamic, options:Dynamic):Dynamic;
	function getTailBufferPosition():TextBuffer.IPoint;
	function setTailBufferPosition(bufferPosition:Dynamic):Dynamic;
	function plantTail():Bool;
	function clearTail():Bool;
	function hasTail():Bool;
	function isReversed():Bool;
	function isValid():Bool;
	function isDestroyed():Bool;
	function getAttributes():Dynamic;
	function setAttributes(attributes:Dynamic):Dynamic;
	function matchesAttributes(attributes:Dynamic):Dynamic;
	function destroy():Dynamic;
	function isEqual(other:IDisplayBufferMarker):Bool;
	function compare(other:IDisplayBufferMarker):Bool;
	function inspect():String;
	function destroyed():Dynamic;
	function notifyObservers(_arg:Dynamic):Dynamic;
};
typedef ITransaction = { };
typedef IMarker = {
	>Emissary.IEmitter,
};
typedef ITaskStatic = {
	function new(taskPath:Dynamic):ITask;
};
typedef ITask = { };
